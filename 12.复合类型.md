# å¤åˆç±»å‹

------

å¤åˆç±»å‹å…è®¸å°†æ›´ç®€å•çš„ç±»å‹ç»„åˆæˆæ›´å¤æ‚çš„ç±»å‹ï¼Œå³å®ƒä»¬å…è®¸å°†å¤šä¸ªå€¼ç»„åˆä¸ºä¸€ä¸ªã€‚å¤åˆç±»å‹æœ‰ä¸€ä¸ªåç§°ï¼Œç”±é›¶ä¸ªæˆ–å¤šä¸ªå‘½åå­—æ®µä»¥åŠé›¶ä¸ªæˆ–å¤šä¸ªå¯¹æ•°æ®è¿›è¡Œæ“ä½œçš„å‡½æ•°ç»„æˆã€‚æ¯ä¸ªå­—æ®µå¯èƒ½æœ‰ä¸åŒçš„ç±»å‹ã€‚

å¤åˆç±»å‹åªèƒ½åœ¨[åˆåŒä¸­](https://docs.onflow.org/cadence/language/contracts)å£°æ˜ï¼Œè€Œä¸èƒ½åœ¨å…¶ä»–åœ°æ–¹å£°æ˜ã€‚

æœ‰ä¸¤ç§å¤åˆç±»å‹ã€‚å½“ä¸€ä¸ªå€¼ç”¨ä½œå¸¸é‡æˆ–å˜é‡çš„åˆå§‹å€¼æ—¶ï¼Œå½“å€¼è¢«åˆ†é…ç»™å˜é‡æ—¶ï¼Œå½“å€¼ä½œä¸ºå‚æ•°ä¼ é€’ç»™å‡½æ•°æ—¶ï¼Œä»¥åŠå½“å€¼æ˜¯ä»å‡½æ•°è¿”å›ï¼š

- [**ç»“æ„**](https://docs.onflow.org/cadence/language/composite-types/#structures)è¢«**å¤åˆ¶**ï¼Œå®ƒä»¬æ˜¯å€¼ç±»å‹ã€‚

  å½“éœ€è¦å…·æœ‰ç‹¬ç«‹çŠ¶æ€çš„å‰¯æœ¬æ—¶ï¼Œç»“æ„å¾ˆæœ‰ç”¨ã€‚

- [**èµ„æº**](https://docs.onflow.org/cadence/language/composite-types/#resources)è¢«**ç§»åŠ¨**ï¼Œå®ƒä»¬æ˜¯çº¿æ€§ç±»å‹å¹¶ä¸”**å¿…é¡»****æ°å¥½**ä½¿ç”¨**ä¸€æ¬¡**ã€‚

  å½“éœ€è¦å¯¹æ‰€æœ‰æƒè¿›è¡Œå»ºæ¨¡æ—¶ï¼Œèµ„æºå¾ˆæœ‰ç”¨ï¼ˆå€¼æ°å¥½å­˜åœ¨äºä¸€ä¸ªä½ç½®å¹¶ä¸”ä¸åº”ä¸¢å¤±ï¼‰ã€‚

  åŒºå—é“¾ä¸­çš„æŸäº›æ„é€ ä»£è¡¨å…·æœ‰çœŸå®ã€æœ‰å½¢ä»·å€¼çš„èµ„äº§ï¼Œå°±åƒæˆ¿å­ã€æ±½è½¦æˆ–é“¶è¡Œè´¦æˆ·ä¸€æ ·ã€‚æˆ‘ä»¬ä¸å¾—ä¸æ‹…å¿ƒå­—é¢ä¸Šçš„æŸå¤±å’Œç›—çªƒï¼Œç”šè‡³å¯èƒ½è¾¾åˆ°æ•°ç™¾ä¸‡ç¾å…ƒçš„è§„æ¨¡ã€‚

  ç»“æ„ä¸æ˜¯è¡¨ç¤ºè¿™ç§æ‰€æœ‰æƒçš„ç†æƒ³æ–¹å¼ï¼Œå› ä¸ºå®ƒä»¬æ˜¯è¢«å¤åˆ¶çš„ã€‚è¿™æ„å‘³ç€å¯èƒ½å­˜åœ¨æŸäº›èµ„äº§çš„å¤šä¸ªå‰¯æœ¬å››å¤„æµåŠ¨çš„é£é™©ï¼Œè¿™æ‰“ç ´äº†è¿™äº›èµ„äº§å…·æœ‰å®é™…ä»·å€¼æ‰€éœ€çš„ç¨€ç¼ºæ€§è¦æ±‚ã€‚

  ç»“æ„å¯¹äºè¡¨ç¤ºå¯ä»¥ä»¥é€»è¾‘æ–¹å¼ç»„åˆåœ¨ä¸€èµ·ä½†æ²¡æœ‰ä»·å€¼æˆ–éœ€è¦èƒ½å¤Ÿè¢«æ‹¥æœ‰æˆ–è½¬ç§»çš„ä¿¡æ¯æ›´æœ‰ç”¨ã€‚

  ä¾‹å¦‚ï¼Œç»“æ„å¯ç”¨äºåŒ…å«ä¸å…¬å¸éƒ¨é—¨ç›¸å…³çš„ä¿¡æ¯ï¼Œä½†èµ„æºå¯ç”¨äºè¡¨ç¤ºå·²åˆ†é…ç»™è¯¥ç»„ç»‡ç”¨äºæ”¯å‡ºçš„èµ„äº§ã€‚

èµ„æºçš„åµŒå¥—åªå…è®¸åœ¨å…¶ä»–èµ„æºç±»å‹ä¸­ï¼Œæˆ–åœ¨æ•°ç»„å’Œå­—å…¸ç­‰æ•°æ®ç»“æ„ä¸­ï¼Œä½†ä¸å…è®¸åœ¨ç»“æ„ä¸­ï¼Œå› ä¸ºè¿™å°†å…è®¸å¤åˆ¶èµ„æºã€‚

## å¤åˆç±»å‹å£°æ˜å’Œåˆ›å»º

ä½¿ç”¨`struct`å…³é”®å­—å£°æ˜ç»“æ„ï¼Œä½¿ç”¨å…³é”®å­—å£°æ˜èµ„æº`resource`ã€‚å…³é”®å­—åè·Ÿåç§°ã€‚

```cadence
pub struct SomeStruct {
    // ...
}

pub resource SomeResource {
    // ...
}
```

ç»“æ„å’Œèµ„æºæ˜¯ç±»å‹ã€‚

é€šè¿‡åƒå‡½æ•°ä¸€æ ·è°ƒç”¨ç±»å‹æ¥åˆ›å»ºï¼ˆå®ä¾‹åŒ–ï¼‰ç»“æ„ã€‚

```cadence
// instantiate a new struct object and assign it to a constant
let a = SomeStruct()
```

å¦‚æœ å¤åˆç±»å‹çš„[åˆå§‹åŒ–ç¨‹åº](https://docs.onflow.org/cadence/language/composite-types/#composite-type-fields)éœ€è¦å‚æ•°ï¼Œåˆ™æ„é€ å‡½æ•°å¯èƒ½éœ€è¦å‚æ•°ã€‚

å¤åˆç±»å‹åªèƒ½åœ¨[å¥‘çº¦ä¸­](https://docs.onflow.org/cadence/language/contracts)å£°æ˜ï¼Œ è€Œä¸èƒ½åœ¨å‡½æ•°ä¸­æœ¬åœ°å£°æ˜ã€‚

å¿…é¡»é€šè¿‡ä½¿ç”¨`create`å…³é”®å­—å¹¶åƒå‡½æ•°ä¸€æ ·è°ƒç”¨ç±»å‹æ¥åˆ›å»ºï¼ˆå®ä¾‹åŒ–ï¼‰èµ„æºã€‚

èµ„æºåªèƒ½åœ¨å£°æ˜èµ„æºçš„åŒä¸€åˆçº¦ä¸­å£°æ˜çš„å‡½æ•°å’Œç±»å‹ä¸­åˆ›å»ºã€‚

```cadence
// instantiate a new resource object and assign it to a constant
let b <- create SomeResource()
```

## å¤åˆç±»å‹å­—æ®µ

å­—æ®µè¢«å£°æ˜ä¸ºå˜é‡å’Œå¸¸é‡ã€‚ä½†æ˜¯ï¼Œå­—æ®µçš„åˆå§‹å€¼æ˜¯åœ¨åˆå§‹åŒ–ç¨‹åºä¸­è®¾ç½®çš„ï¼Œ **è€Œä¸æ˜¯**åœ¨å­—æ®µå£°æ˜ä¸­è®¾ç½®çš„ã€‚æ‰€æœ‰å­—æ®µéƒ½**å¿…é¡»**åœ¨åˆå§‹åŒ–ç¨‹åºä¸­åˆå§‹åŒ–ä¸€æ¬¡ã€‚

å¿…é¡»åœ¨åˆå§‹åŒ–ç¨‹åºä¸­æä¾›åˆå§‹å€¼ä¼¼ä¹å—åˆ°é™åˆ¶ï¼Œä½†è¿™å¯ç¡®ä¿æ‰€æœ‰å­—æ®µå§‹ç»ˆåœ¨ä¸€ä¸ªä½ç½®åˆå§‹åŒ–ï¼Œå³åˆå§‹åŒ–ç¨‹åºï¼Œå¹¶ä¸”åˆå§‹åŒ–é¡ºåºæ˜¯æ˜ç¡®çš„ã€‚

é™æ€æ£€æŸ¥æ‰€æœ‰å­—æ®µçš„åˆå§‹åŒ–ï¼Œä¸åˆå§‹åŒ–åˆå§‹åŒ–å™¨ä¸­çš„æ‰€æœ‰å­—æ®µæ˜¯æ— æ•ˆçš„ã€‚æ­¤å¤–ï¼Œé™æ€æ£€æŸ¥å­—æ®µåœ¨ä½¿ç”¨å‰æ˜¯å¦å·²æ˜ç¡®åˆå§‹åŒ–ã€‚

åˆå§‹åŒ–ç¨‹åºçš„ä¸»è¦ç›®çš„æ˜¯åˆå§‹åŒ–å­—æ®µï¼Œå°½ç®¡å®ƒä¹Ÿå¯èƒ½åŒ…å«å…¶ä»–ä»£ç ã€‚å°±åƒå‡½æ•°ä¸€æ ·ï¼Œå®ƒå¯ä»¥å£°æ˜å‚æ•°å¹¶ä¸”å¯ä»¥åŒ…å«ä»»æ„ä»£ç ã€‚ä½†æ˜¯ï¼Œå®ƒæ²¡æœ‰è¿”å›ç±»å‹ï¼Œå³å§‹ç»ˆä¸º`Void`ã€‚

åˆå§‹åŒ–å™¨æ˜¯ä½¿ç”¨`init`å…³é”®å­—å£°æ˜çš„ã€‚

åˆå§‹å€¼è®¾å®šé¡¹å§‹ç»ˆè·Ÿåœ¨ä»»ä½•å­—æ®µä¹‹åã€‚

å…±æœ‰ä¸‰ç§å­—æ®µï¼š

- **å¸¸é‡å­—æ®µ**ä¹Ÿå­˜å‚¨åœ¨å¤åˆå€¼ä¸­ï¼Œä½†åœ¨ç”¨å€¼åˆå§‹åŒ–åï¼Œå®ƒä»¬**ä¸èƒ½**å†åˆ†é…æ–°å€¼ã€‚ä¸€ä¸ªå¸¸é‡å­—æ®µå¿…é¡»è¢«åˆå§‹åŒ–ä¸€æ¬¡ã€‚

  å¸¸é‡å­—æ®µä½¿ç”¨`let`å…³é”®å­—å£°æ˜ã€‚

- **å˜é‡å­—æ®µ**å­˜å‚¨åœ¨å¤åˆå€¼ä¸­ï¼Œå¹¶ä¸”å¯ä»¥ä¸ºå…¶åˆ†é…æ–°å€¼ã€‚

  å˜é‡å­—æ®µä½¿ç”¨`var`å…³é”®å­—å£°æ˜ã€‚

- **åˆæˆé¢†åŸŸ**ä¸­**æ²¡æœ‰å­˜å‚¨**åœ¨å¤åˆå€¼ï¼Œå³ï¼Œå®ƒä»¬æ˜¯è¡ç”Ÿçš„/ä»å…¶ä»–å€¼æ¥è®¡ç®—ã€‚å¯ä»¥ä¸ºå®ƒä»¬åˆ†é…æ–°å€¼ã€‚

  åˆæˆå­—æ®µä½¿ç”¨`synthetic`å…³é”®å­—å£°æ˜ã€‚

  åˆæˆå­—æ®µå¿…é¡»æœ‰ä¸€ä¸ª getter å’Œä¸€ä¸ª setterã€‚[ä¸‹ä¸€èŠ‚](https://docs.onflow.org/cadence/language/composite-types/#composite-type-field-getters-and-setters)å°†è§£é‡Š getter å’Œ setter ã€‚åˆæˆå­—æ®µåœ¨[å•ç‹¬çš„éƒ¨åˆ†](https://docs.onflow.org/cadence/language/composite-types/#synthetic-composite-type-fields)ä¸­è§£é‡Šã€‚

| å­—æ®µç§ç±»     | å­˜å‚¨åœ¨å†…å­˜ä¸­ | å¯åˆ†é… | å…³é”®è¯      |
| ------------ | ------------ | ------ | ----------- |
| **å˜é‡å­—æ®µ** | æ˜¯çš„         | æ˜¯çš„   | `var`       |
| **å¸¸æ•°åœº**   | æ˜¯çš„         | **ä¸** | `let`       |
| **åˆæˆåœº**   | **ä¸**       | æ˜¯çš„   | `synthetic` |

åœ¨åˆå§‹åŒ–å™¨ä¸­ï¼Œç‰¹æ®Šå¸¸é‡`self`æŒ‡çš„æ˜¯è¦åˆå§‹åŒ–çš„å¤åˆå€¼ã€‚

å­—æ®µç±»å‹å¿…é¡»æ˜¯å¯å­˜å‚¨çš„ã€‚ä¸å¯å­˜å‚¨çš„ç±»å‹æœ‰ï¼š

- èŒèƒ½
- [å¸æˆ· ( `AuthAccount`/ `PublicAccount`)](https://docs.onflow.org/cadence/language/accounts)
- [äº¤æ˜“](https://docs.onflow.org/cadence/language/transactions)
- [å‚è€ƒèµ„æ–™](https://docs.onflow.org/cadence/language/references)ï¼šå‚è€ƒèµ„æ–™æ˜¯çŸ­æš‚çš„ã€‚è€ƒè™‘[å­˜å‚¨èƒ½åŠ›å¹¶](https://docs.onflow.org/cadence/language/capability-based-access-control)åœ¨éœ€è¦æ—¶[å€Ÿç”¨å®ƒ](https://docs.onflow.org/cadence/language/capability-based-access-control)ã€‚

å¯ä»¥ä½¿ç”¨è®¿é—®è¯­æ³•è¯»å–ï¼ˆå¦‚æœå®ƒä»¬æ˜¯å¸¸é‡æˆ–å¯å˜çš„ï¼‰å’Œè®¾ç½®ï¼ˆå¦‚æœå®ƒä»¬æ˜¯å¯å˜çš„ï¼‰`.`å­—æ®µï¼šå¤åˆå€¼åè·Ÿä¸€ä¸ªç‚¹ ( ) å’Œå­—æ®µçš„åç§°ã€‚

```cadence
// Declare a structure named `Token`, which has a constant field
// named `id` and a variable field named `balance`.
//
// Both fields are initialized through the initializer.
//
// The public access modifier `pub` is used in this example to allow
// the fields to be read in outer scopes. Fields can also be declared
// private so they cannot be accessed in outer scopes.
// Access control will be explained in a later section.
//
pub struct Token {
    pub let id: Int
    pub var balance: Int

    init(id: Int, balance: Int) {
        self.id = id
        self.balance = balance
    }
}
```

è¯·æ³¨æ„ï¼Œåœ¨å­—æ®µå£°æ˜ä¸­ä¸ºå­—æ®µæä¾›åˆå§‹å€¼æ˜¯æ— æ•ˆçš„ã€‚

```cadence
pub struct StructureWithConstantField {
    // Invalid: It is invalid to provide an initial value in the field declaration.
    // The field must be initialized by setting the initial value in the initializer.
    //
    pub let id: Int = 1
}
```

å¿…é¡»ä½¿ç”¨å­—æ®µè®¿é—®è¯­æ³•æ¥è®¿é—®å­—æ®µâ€”â€”å­—æ®µä¸èƒ½ä½œä¸ºå˜é‡ä½¿ç”¨ã€‚

```cadence
pub struct Token {
    pub let id: Int

    init(initialID: Int) {
        // Invalid: There is no variable with the name `id` available.
        // The field `id` must be initialized by setting `self.id`.
        //
        id = initialID
    }
}
```

åˆå§‹å€¼è®¾å®šé¡¹**ä¸æ˜¯**ä»å­—æ®µè‡ªåŠ¨æ´¾ç”Ÿçš„ï¼Œå®ƒå¿…é¡»æ˜¾å¼å£°æ˜ã€‚

```cadence
pub struct Token {
    pub let id: Int

    // Invalid: Missing initializer initializing field `id`.
}
```

å¯ä»¥é€šè¿‡è°ƒç”¨æ„é€ å‡½æ•°å¹¶æä¾›å­—æ®µå€¼ä½œä¸ºå‚æ•°æ¥åˆ›å»ºå¤åˆå€¼ã€‚

åˆ›å»ºå¯¹è±¡åï¼Œå¯ä»¥åœ¨å¯¹è±¡ä¸Šè®¿é—®å€¼çš„å­—æ®µã€‚

```cadence
let token = Token(id: 42, balance: 1_000_00)

token.id  // is `42`
token.balance  // is `1_000_000`

token.balance = 1
// `token.balance` is `1`

// Invalid: assignment to constant field
//
token.id = 23
```

## èµ„æºæ‰€æœ‰è€…

èµ„æºå…·æœ‰éšå¼å­—æ®µ`let owner: PublicAccount?`ã€‚å¦‚æœèµ„æºå½“å‰[å­˜å‚¨åœ¨ account ä¸­](https://docs.onflow.org/cadence/language/accounts#account-storage)ï¼Œåˆ™è¯¥å­—æ®µåŒ…å«è¯¥å¸æˆ·çš„å¯å…¬å¼€è®¿é—®éƒ¨åˆ†ã€‚å¦åˆ™è¯¥å­—æ®µä¸º`nil`ã€‚

å½“èµ„æºä»å¤–éƒ¨è´¦æˆ·å­˜å‚¨ç§»åŠ¨åˆ°è´¦æˆ·å­˜å‚¨æ—¶ï¼Œå½“å®ƒä»ä¸€ä¸ªè´¦æˆ·çš„å­˜å‚¨ç§»åŠ¨åˆ°å¦ä¸€ä¸ªè´¦æˆ·çš„å­˜å‚¨æ—¶ï¼Œä»¥åŠå½“å®ƒä»è´¦æˆ·å­˜å‚¨ä¸­ç§»å‡ºæ—¶ï¼Œè¯¥å­—æ®µçš„å€¼ä¼šå‘ç”Ÿå˜åŒ–ã€‚

## å¤åˆæ•°æ®åˆå§‹åŒ–å™¨é‡è½½

ğŸš§ çŠ¶æ€ï¼šåˆå§‹åŒ–å™¨é‡è½½å°šæœªå®ç°ã€‚

åˆå§‹åŒ–ç¨‹åºæ”¯æŒé‡è½½ã€‚è¿™å…è®¸ä¾‹å¦‚ä¸ºæŸäº›å‚æ•°æä¾›é»˜è®¤å€¼ã€‚

```cadence
// Declare a structure named `Token`, which has a constant field
// named `id` and a variable field named `balance`.
//
// The first initializer allows initializing both fields with a given value.
//
// A second initializer is provided for convenience to initialize the `id` field
// with a given value, and the `balance` field with the default value `0`.
//
pub struct Token {
    let id: Int
    var balance: Int

    init(id: Int, balance: Int) {
        self.id = id
        self.balance = balance
    }

    init(id: Int) {
        self.id = id
        self.balance = 0
    }
}
```

## å¤åˆç±»å‹å­—æ®µ Getter å’Œ Setter

ğŸš§ çŠ¶æ€ï¼šå­—æ®µ getter å’Œ setter å°šæœªå®ç°ã€‚

å­—æ®µå¯èƒ½æœ‰ä¸€ä¸ªå¯é€‰çš„ getter å’Œä¸€ä¸ªå¯é€‰çš„ setterã€‚getter æ˜¯è¯»å–å­—æ®µæ—¶è°ƒç”¨çš„å‡½æ•°ï¼Œsetter æ˜¯å†™å…¥å­—æ®µæ—¶è°ƒç”¨çš„å‡½æ•°ã€‚åœ¨ getter å’Œ setter ä¸­åªå…è®¸æŸäº›èµ‹å€¼ã€‚

åœ¨å­—æ®µç±»å‹ä¹‹åï¼Œgetter å’Œ setter ç”¨å·¦æ‹¬å·å’Œå³æ‹¬å·æ‹¬èµ·æ¥ã€‚

Getter æ˜¯ä½¿ç”¨`get`å…³é”®å­—å£°æ˜çš„ã€‚Getter æ²¡æœ‰å‚æ•°ï¼Œå®ƒä»¬çš„è¿”å›ç±»å‹éšå¼æ˜¯å­—æ®µçš„ç±»å‹ã€‚

```cadence
pub struct GetterExample {

    // Declare a variable field named `balance` with a getter
    // which ensures the read value is always non-negative.
    //
    pub var balance: Int {
        get {
           if self.balance < 0 {
               return 0
           }

           return self.balance
        }
    }

    init(balance: Int) {
        self.balance = balance
    }
}

let example = GetterExample(balance: 10)
// `example.balance` is `10`

example.balance = -50
// The stored value of the field `example` is `-50` internally,
// though `example.balance` is `0` because the getter for `balance` returns `0` instead.
```

Setter ä½¿ç”¨`set`å…³é”®å­—å£°æ˜ï¼Œåè·Ÿæ‹¬åœ¨æ‹¬å·ä¸­çš„æ–°å€¼çš„åç§°ã€‚è¯¥å‚æ•°éšå«äº†å­—æ®µçš„ç±»å‹ã€‚ä¸èƒ½æŒ‡å®šå…¶ä»–ç±»å‹ã€‚Setter æ²¡æœ‰è¿”å›ç±»å‹ã€‚

åˆ†é…ç»™ setter çš„å€¼çš„ç±»å‹å¿…é¡»å§‹ç»ˆä¸å­—æ®µçš„ç±»å‹åŒ¹é…ã€‚

```cadence
pub struct SetterExample {

    // Declare a variable field named `balance` with a setter
    // which requires written values to be positive.
    //
    pub var balance: Int {
        set(newBalance) {
            pre {
                newBalance >= 0
            }
            self.balance = newBalance
        }
    }

    init(balance: Int) {
        self.balance = balance
    }
}

let example = SetterExample(balance: 10)
// `example.balance` is `10`

// Run-time error: The precondition of the setter for the field `balance` fails,
// the program aborts.
//
example.balance = -50
```

## åˆæˆå¤åˆç±»å‹å­—æ®µ

ğŸš§ çŠ¶æ€ï¼šåˆæˆå­—æ®µå°šæœªå®ç°ã€‚

æœªå­˜å‚¨åœ¨å¤åˆå€¼ä¸­çš„å­—æ®µæ˜¯*åˆæˆçš„*ï¼Œå³è®¡ç®—å­—æ®µå€¼ã€‚Synthetic å¯ä»¥æ˜¯åªè¯»çš„ï¼Œä¹Ÿå¯ä»¥æ˜¯å¯è¯»å¯å†™çš„ã€‚

åˆæˆå­—æ®µä½¿ç”¨`synthetic`å…³é”®å­—å£°æ˜ã€‚

å½“ä»…æä¾› getter æ—¶ï¼Œåˆæˆå­—æ®µæ˜¯åªè¯»çš„ã€‚

```cadence
struct Rectangle {
    pub var width: Int
    pub var height: Int

    // Declare a synthetic field named `area`,
    // which computes the area based on the `width` and `height` fields.
    //
    pub synthetic area: Int {
        get {
            return width * height
        }
    }

    // Declare an initializer which accepts width and height.
    // As `area` is synthetic and there is only a getter provided for it,
    // the `area` field cannot be assigned a value.
    //
    init(width: Int, height: Int) {
        self.width = width
        self.height = height
    }
}
```

å½“åŒæ—¶å£°æ˜äº† getter å’Œ setter æ—¶ï¼Œåˆæˆå­—æ®µæ˜¯å¯è¯»å’Œå¯å†™çš„ã€‚

```cadence
// Declare a struct named `GoalTracker` which stores a number
// of target goals, a number of completed goals,
// and has a synthetic field to provide the left number of goals.
//
// NOTE: the tracker only implements some functionality to demonstrate
// synthetic fields, it is incomplete (e.g. assignments to `goal` are not handled properly).
//
pub struct GoalTracker {

    pub var goal: Int
    pub var completed: Int

    // Declare a synthetic field which is both readable and writable.
    //
    // When the field is read from (in the getter), the number
    // of left goals is computed from the target number of goals
    // and the completed number of goals.
    //
    // When the field is written to (in the setter), the number
    // of completed goals is updated, based on the number
    // of target goals and the new remaining number of goals.
    //
    pub synthetic left: Int {
        get {
            return self.goal - self.completed
        }

        set(newLeft) {
            self.completed = self.goal - newLeft
        }
    }

    init(goal: Int, completed: Int) {
        self.goal = goal
        self.completed = completed
    }
}

let tracker = GoalTracker(goal: 10, completed: 0)
// `tracker.goal` is `10`
// `tracker.completed` is `0`
// `tracker.left` is `10`

tracker.completed = 1
// `tracker.left` is `9`

tracker.left = 8
// `tracker.completed` is `2`
```

ä»…ä½¿ç”¨ setter å£°æ˜åˆæˆå­—æ®µæ˜¯æ— æ•ˆçš„ã€‚

## å¤åˆç±»å‹å‡½æ•°

ğŸš§ çŠ¶æ€ï¼šå‡½æ•°é‡è½½è¿˜æ²¡æœ‰å®ç°ã€‚

å¤åˆç±»å‹å¯èƒ½åŒ…å«å‡½æ•°ã€‚å°±åƒåœ¨åˆå§‹åŒ–ç¨‹åºä¸­ä¸€æ ·ï¼Œç‰¹æ®Šå¸¸é‡`self`æŒ‡çš„æ˜¯è°ƒç”¨å‡½æ•°çš„å¤åˆå€¼ã€‚

```cadence
// Declare a structure named "Rectangle", which represents a rectangle
// and has variable fields for the width and height.
//
pub struct Rectangle {
    pub var width: Int
    pub var height: Int

    init(width: Int, height: Int) {
        self.width = width
        self.height = height
    }

    // Declare a function named "scale", which scales
    // the rectangle by the given factor.
    //
    pub fun scale(factor: Int) {
        self.width = self.width * factor
        self.height = self.height * factor
    }
}

let rectangle = Rectangle(width: 2, height: 3)
rectangle.scale(factor: 4)
// `rectangle.width` is `8`
// `rectangle.height` is `12`
```

å‡½æ•°æ”¯æŒé‡è½½ã€‚

```cadence
// Declare a structure named "Rectangle", which represents a rectangle
// and has variable fields for the width and height.
//
pub struct Rectangle {
    pub var width: Int
    pub var height: Int

    init(width: Int, height: Int) {
        self.width = width
        self.height = height
    }

    // Declare a function named "scale", which independently scales
    // the width by a given factor and the height by a given factor.
    //
    pub fun scale(widthFactor: Int, heightFactor: Int) {
        self.width = self.width * widthFactor
        self.height = self.height * heightFactor
    }

    // Declare another function also named "scale", which scales
    // both width and height by a given factor.
    // The function calls the `scale` function declared above.
    //
    pub fun scale(factor: Int) {
        self.scale(
            widthFactor: factor,
            heightFactor: factor
        )
    }
}
```

## å¤åˆç±»å‹å­ç±»å‹

ä¸¤ä¸ªå¤åˆç±»å‹æ˜¯å…¼å®¹çš„ï¼Œå½“ä¸”ä»…å½“å®ƒä»¬é€šè¿‡åç§°å¼•ç”¨ç›¸åŒçš„å£°æ˜ï¼Œå³åº”ç”¨åä¹‰ç±»å‹è€Œä¸æ˜¯ç»“æ„ç±»å‹ã€‚

å³ä½¿ä¸¤ä¸ªå¤åˆç±»å‹å£°æ˜äº†ç›¸åŒçš„å­—æ®µå’Œå‡½æ•°ï¼Œè¿™äº›ç±»å‹ä¹Ÿåªæœ‰åœ¨åç§°åŒ¹é…æ—¶æ‰å…¼å®¹ã€‚

```cadence
// Declare a structure named `A` which has a function `test`
// which has type `((): Void)`.
//
struct A {
    fun test() {}
}

// Declare a structure named `B` which has a function `test`
// which has type `((): Void)`.
//
struct B {
    fun test() {}
}

// Declare a variable named which accepts values of type `A`.
//
var something: A = A()

// Invalid: Assign a value of type `B` to the variable.
// Even though types `A` and `B` have the same declarations,
// a function with the same name and type, the types' names differ,
// so they are not compatible.
//
something = B()

// Valid: Reassign a new value of type `A`.
//
something = A()
```

## å¤åˆç±»å‹è¡Œä¸º

### ç»“æ„

å½“ç”¨ä½œå¸¸é‡æˆ–å˜é‡çš„åˆå§‹å€¼ã€åˆ†é…ç»™ä¸åŒçš„å˜é‡ã€ä½œä¸ºå‚æ•°ä¼ é€’ç»™å‡½æ•°ä»¥åŠä»å‡½æ•°è¿”å›æ—¶ï¼Œç»“æ„å°†è¢«**å¤åˆ¶**ã€‚

è®¿é—®å­—æ®µæˆ–è°ƒç”¨ç»“æ„çš„å‡½æ•°ä¸ä¼šå¤åˆ¶å®ƒã€‚

```cadence
// Declare a structure named `SomeStruct`, with a variable integer field.
//
pub struct SomeStruct {
    pub var value: Int

    init(value: Int) {
        self.value = value
    }

    fun increment() {
        self.value = self.value + 1
    }
}

// Declare a constant with value of structure type `SomeStruct`.
//
let a = SomeStruct(value: 0)

// *Copy* the structure value into a new constant.
//
let b = a

b.value = 1
// NOTE: `b.value` is 1, `a.value` is *`0`*

b.increment()
// `b.value` is 2, `a.value` is `0`
```

### ä½¿ç”¨å¯é€‰é“¾è®¿é—®å¤åˆç±»å‹çš„å­—æ®µå’Œå‡½æ•°

å¦‚æœå…·æœ‰å­—æ®µå’Œå‡½æ•°çš„å¤åˆç±»å‹è¢«åŒ…è£…åœ¨ä¸€ä¸ªå¯é€‰é¡¹ä¸­ï¼Œåˆ™å¯ä»¥ä½¿ç”¨å¯é€‰é¡¹é“¾æ¥è·å–è¿™äº›å€¼æˆ–è°ƒç”¨å‡½æ•°ï¼Œè€Œä¸å¿…å…ˆè·å–å¯é€‰é¡¹çš„å€¼ã€‚

å¯é€‰é“¾æ˜¯é€šè¿‡`?` åœ¨`.`å¯é€‰å¤åˆç±»å‹çš„å­—æ®µæˆ–å‡½æ•°çš„è®¿é—®è¿ç®—ç¬¦ä¹‹å‰æ·»åŠ  a æ¥ä½¿ç”¨çš„ã€‚

å½“è·å–å­—æ®µå€¼æˆ–è°ƒç”¨å…·æœ‰è¿”å›å€¼çš„å‡½æ•°æ—¶ï¼Œè®¿é—®ä¼šå°†è¯¥å€¼ä½œä¸ºå¯é€‰é¡¹è¿”å›ã€‚å¦‚æœå¯¹è±¡ä¸å­˜åœ¨ï¼Œåˆ™å€¼å°†å§‹ç»ˆä¸º`nil`

å½“åœ¨è¿™æ ·çš„å¯é€‰é¡¹ä¸Šè°ƒç”¨å‡½æ•°æ—¶ï¼Œå¦‚æœå¯¹è±¡ä¸å­˜åœ¨ï¼Œåˆ™ä»€ä¹ˆéƒ½ä¸ä¼šå‘ç”Ÿï¼Œæ‰§è¡Œå°†ç»§ç»­ã€‚

è®¿é—®å¯é€‰å¤åˆç±»å‹çš„æœªå£°æ˜å­—æ®µä»ç„¶æ— æ•ˆã€‚

```cadence
// Declare a struct with a field and method.
pub struct Value {
    pub var number: Int

    init() {
        self.number = 2
    }

    pub fun set(new: Int) {
        self.number = new
    }

    pub fun setAndReturn(new: Int): Int {
        self.number = new
        return new
    }
}

// Create a new instance of the struct as an optional
let value: Value? = Value()
// Create another optional with the same type, but nil
let noValue: Value? = nil

// Access the `number` field using optional chaining
let twoOpt = value?.number
// Because `value` is an optional, `twoOpt` has type `Int?`
let two = twoOpt ?? 0
// `two` is `2`

// Try to access the `number` field of `noValue`, which has type `Value?`.
// This still returns an `Int?`
let nilValue = noValue?.number
// This time, since `noValue` is `nil`, `nilValue` will also be `nil`

// Try to call the `set` function of `value`.
// The function call is performed, as `value` is not nil
value?.set(new: 4)

// Try to call the `set` function of `noValue`.
// The function call is *not* performed, as `noValue` is nil
noValue?.set(new: 4)

// Call the `setAndReturn` function, which returns an `Int`.
// Because `value` is an optional, the return value is type `Int?`
let sixOpt = value?.setAndReturn(new: 6)
let six = sixOpt ?? 0
// `six` is `6`
```

è¿™ä¹Ÿå¯ä»¥é€šè¿‡ä½¿ç”¨å¼ºåˆ¶å±•å¼€è¿ç®—ç¬¦ ( `!`) æ¥å®ç°ã€‚

é€šè¿‡`!` åœ¨`.`å¯é€‰å¤åˆç±»å‹çš„å­—æ®µæˆ–å‡½æ•°çš„è®¿é—®è¿ç®—ç¬¦ä¹‹å‰æ·»åŠ  a æ¥ä½¿ç”¨å¼ºåˆ¶å¯é€‰é“¾æ¥ã€‚

å½“è·å–å­—æ®µå€¼æˆ–è°ƒç”¨å¸¦æœ‰è¿”å›å€¼çš„å‡½æ•°æ—¶ï¼Œè®¿é—®ä¼šè¿”å›è¯¥å€¼ã€‚å¦‚æœå¯¹è±¡ä¸å­˜åœ¨ï¼Œåˆ™æ‰§è¡Œå°†ææ…Œå¹¶æ¢å¤ã€‚

è®¿é—®å¯é€‰å¤åˆç±»å‹çš„æœªå£°æ˜å­—æ®µä»ç„¶æ— æ•ˆã€‚

```cadence
// Declare a struct with a field and method.
pub struct Value {
    pub var number: Int

    init() {
        self.number = 2
    }

    pub fun set(new: Int) {
        self.number = new
    }

    pub fun setAndReturn(new: Int): Int {
        self.number = new
        return new
    }
}

// Create a new instance of the struct as an optional
let value: Value? = Value()
// Create another optional with the same type, but nil
let noValue: Value? = nil

// Access the `number` field using force-optional chaining
let two = value!.number
// `two` is `2`

// Try to access the `number` field of `noValue`, which has type `Value?`
// Run-time error: This time, since `noValue` is `nil`,
// the program execution will revert
let number = noValue!.number

// Call the `set` function of the struct

// This succeeds and sets the value to 4
value!.set(new: 4)

// Run-time error: Since `noValue` is nil, the value is not set
// and the program execution reverts.
noValue!.set(new: 4)

// Call the `setAndReturn` function, which returns an `Int`
// Because we use force-unwrap before calling the function,
// the return value is type `Int`
let six = value!.setAndReturn(new: 6)
// `six` is `6`
```

### èµ„æº

èµ„æºæ˜¯ä¸€æ¬¡åªèƒ½å­˜åœ¨äº**ä¸€ä¸ª**ä½ç½®å¹¶ä¸”**å¿…é¡»****æ°å¥½**ä½¿ç”¨**ä¸€æ¬¡çš„ç±»å‹**ã€‚

**å¿…é¡»**ä½¿ç”¨`create`å…³é”®å­—åˆ›å»ºï¼ˆå®ä¾‹åŒ–ï¼‰èµ„æºã€‚

åœ¨å…·æœ‰åœ¨èŒƒå›´èµ„æºï¼ˆå˜é‡ï¼Œå¸¸é‡å‚æ•°ï¼‰çš„å‡½æ•°çš„ç»“æŸæ—¶ï¼Œèµ„æº**å¿…é¡»**è¢«ä»»ä¸€**ç§»åŠ¨**æˆ–**ç ´å**ã€‚

å½“ç”¨ä½œå¸¸é‡æˆ–å˜é‡çš„åˆå§‹å€¼ã€åˆ†é…ç»™ä¸åŒçš„å˜é‡ã€ä½œä¸ºå‚æ•°ä¼ é€’ç»™å‡½æ•°ä»¥åŠä»å‡½æ•°è¿”å›æ—¶ï¼Œå®ƒä»¬éƒ½ä¼šè¢«**ç§»åŠ¨**ã€‚

å¯ä»¥ä½¿ç”¨å…³é”®å­—æ˜¾å¼**é”€æ¯**èµ„æº`destroy`ã€‚

è®¿é—®å­—æ®µæˆ–è°ƒç”¨èµ„æºçš„å‡½æ•°ä¸ä¼šç§»åŠ¨æˆ–ç ´åå®ƒã€‚

ç§»åŠ¨èµ„æºæ—¶ï¼Œç§»åŠ¨å‰å¼•ç”¨èµ„æºçš„å¸¸é‡æˆ–å˜é‡å°†å˜ä¸º**æ— æ•ˆ**ã€‚ä¸€ä¸ª**æ— æ•ˆçš„**èµ„æºä¸èƒ½å†ä½¿ç”¨ã€‚

ä¸ºäº†æ˜ç¡®èµ„æºç±»å‹çš„ç”¨æ³•å’Œè¡Œä¸ºï¼Œ`@`å¿…é¡»åœ¨å˜é‡æˆ–å¸¸é‡å£°æ˜ã€å‚æ•°å’Œè¿”å›ç±»å‹çš„ç±»å‹æ³¨é‡Šä¸­ä½¿ç”¨å‰ç¼€ã€‚

ä¸ºäº†æ˜ç¡®åœ°ç§»åŠ¨èµ„æºï¼Œ`<-`å½“èµ„æºæ˜¯å¸¸é‡æˆ–å˜é‡çš„åˆå§‹å€¼æ—¶ï¼Œå½“å®ƒè¢«ç§»åŠ¨åˆ°ä¸€ä¸ªä¸åŒçš„å˜é‡æ—¶ï¼Œå½“å®ƒè¢«ç§»åŠ¨åˆ°ä¸€ä¸ªå‡½æ•°ä½œä¸ºå‚æ•°æ—¶ï¼Œä»¥åŠå½“å®ƒæ˜¯ä»å‡½æ•°è¿”å›ã€‚



```cadence
// Declare a resource named `SomeResource`, with a variable integer field.
//
pub resource SomeResource {
    pub var value: Int

    init(value: Int) {
        self.value = value
    }
}

// Declare a constant with value of resource type `SomeResource`.
//
let a: @SomeResource <- create SomeResource(value: 0)

// *Move* the resource value to a new constant.
//
let b <- a

// Invalid: Cannot use constant `a` anymore as the resource that it referred to
// was moved to constant `b`.
//
a.value

// Constant `b` owns the resource.
//
b.value // equals 0

// Declare a function which accepts a resource.
//
// The parameter has a resource type, so the type annotation must be prefixed with `@`.
//
pub fun use(resource: @SomeResource) {
    // ...
}

// Call function `use` and move the resource into it.
//
use(resource: <-b)

// Invalid: Cannot use constant `b` anymore as the resource
// it referred to was moved into function `use`.
//
b.value
```

èµ„æºå¯¹è±¡ä¸èƒ½è¶…å‡ºèŒƒå›´å¹¶åŠ¨æ€ä¸¢å¤±ã€‚ç¨‹åºå¿…é¡»æ˜¾å¼é”€æ¯å®ƒæˆ–å°†å…¶ç§»åŠ¨åˆ°å¦ä¸€ä¸ªä¸Šä¸‹æ–‡ã€‚

```cadence
{
    // Declare another, unrelated value of resource type `SomeResource`.
    //
    let c <- create SomeResource(value: 10)

    // Invalid: `c` is not used before the end of the scope, but must be.
    // It cannot be lost.
}
```

```cadence
// Declare another, unrelated value of resource type `SomeResource`.
//
let d <- create SomeResource(value: 20)

// Destroy the resource referred to by constant `d`.
//
destroy d

// Invalid: Cannot use constant `d` anymore as the resource
// it referred to was destroyed.
//
d.value
```

ä¸ºäº†æ˜ç¡®è¯¥ç±»å‹æ˜¯ä¸€ç§èµ„æºç±»å‹å¹¶ä¸”å¿…é¡»éµå¾ªä¸èµ„æºç›¸å…³çš„è§„åˆ™ï¼Œå®ƒå¿…é¡»`@`åœ¨æ‰€æœ‰ç±»å‹æ³¨é‡Šä¸­åŠ ä¸Šå‰ç¼€ï¼Œä¾‹å¦‚å¯¹äºå˜é‡å£°æ˜ã€å‚æ•°æˆ–è¿”å›ç±»å‹ã€‚

```cadence
// Declare a constant with an explicit type annotation.
//
// The constant has a resource type, so the type annotation must be prefixed with `@`.
//
let someResource: @SomeResource <- create SomeResource(value: 5)

// Declare a function which consumes a resource and destroys it.
//
// The parameter has a resource type, so the type annotation must be prefixed with `@`.
//
pub fun use(resource: @SomeResource) {
    destroy resource
}

// Declare a function which returns a resource.
//
// The return type is a resource type, so the type annotation must be prefixed with `@`.
// The return statement must also use the `<-` operator to make it explicit the resource is moved.
//
pub fun get(): @SomeResource {
    let newResource <- create SomeResource()
    return <-newResource
}
```

èµ„æº**å¿…é¡»**æ°å¥½ä½¿ç”¨ä¸€æ¬¡ã€‚

```cadence
// Declare a function which consumes a resource but does not use it.
// This function is invalid, because it would cause a loss of the resource.
//
pub fun forgetToUse(resource: @SomeResource) {
    // Invalid: The resource parameter `resource` is not used, but must be.
}
```

```cadence
// Declare a constant named `res` which has the resource type `SomeResource`.
let res <- create SomeResource()

// Call the function `use` and move the resource `res` into it.
use(resource: <-res)

// Invalid: The resource constant `res` cannot be used again,
// as it was moved in the previous function call.
//
use(resource: <-res)

// Invalid: The resource constant `res` cannot be used again,
// as it was moved in the previous function call.
//
res.value
```

```cadence
// Declare a function which has a resource parameter.
// This function is invalid, because it does not always use the resource parameter,
// which would cause a loss of the resource.
//
pub fun sometimesDestroy(resource: @SomeResource, destroyResource: Bool) {
    if destroyResource {
        destroy resource
    }
    // Invalid: The resource parameter `resource` is not always used, but must be.
    // The destroy statement is not always executed, so at the end of this function
    // it might have been destroyed or not.
}
```

```cadence
// Declare a function which has a resource parameter.
// This function is valid, as it always uses the resource parameter,
// and does not cause a loss of the resource.
//
pub fun alwaysUse(resource: @SomeResource, destroyResource: Bool) {
    if destroyResource {
        destroy resource
    } else {
        use(resource: <-resource)
    }
    // At the end of the function the resource parameter was definitely used:
    // It was either destroyed or moved in the call of function `use`.
}
```

```cadence
// Declare a function which has a resource parameter.
// This function is invalid, because it does not always use the resource parameter,
// which would cause a loss of the resource.
//
pub fun returnBeforeDestroy(move: Bool) {
    let res <- create SomeResource(value: 1)
    if move {
        use(resource: <-res)
        return
    } else {
        // Invalid: When this function returns here, the resource variable
        // `res` was not used, but must be.
        return
    }
    // Invalid: the resource variable `res` was potentially moved in the
    // previous if-statement, and both branches definitely return,
    // so this statement is unreachable.
    destroy res
}
```

### èµ„æºå˜é‡

ä¸èƒ½åˆ†é…èµ„æºå˜é‡ï¼Œå› ä¸ºè¿™ä¼šå¯¼è‡´å˜é‡å½“å‰èµ„æºå€¼çš„ä¸¢å¤±ã€‚

ç›¸åï¼Œä½¿ç”¨ swap è¯­å¥ ( `<->`) æˆ– shift è¯­å¥ ( `<- target <-`) å°†èµ„æºå˜é‡æ›¿æ¢ä¸ºå¦ä¸€ä¸ªèµ„æºã€‚

```cadence
pub resource R {}

var x <- create R()
var y <- create R()

// Invalid: Cannot assign to resource variable `x`,
// as its current resource would be lost
//
x <- y

// Instead, use a swap statement.
//
var replacement <- create R()
x <-> replacement
// `x` is the new resource.
// `replacement` is the old resource.

// Or use the shift statement (`<- target <-`)
// This statement moves the resource out of `x` and into `oldX`,
// and at the same time assigns `x` with the new value on the right-hand side.
let oldX <- x <- create R()
// oldX still needs to be explicitly handled after this statement
destroy oldX
```

### èµ„æºææ„å‡½æ•°

èµ„æºå¯èƒ½æœ‰ä¸€ä¸ªææ„å‡½æ•°ï¼Œå®ƒåœ¨èµ„æºè¢«é”€æ¯æ—¶æ‰§è¡Œã€‚ææ„å‡½æ•°æ²¡æœ‰å‚æ•°å’Œè¿”å›å€¼ï¼Œå¹¶ä½¿ç”¨`destroy`åç§°å£°æ˜ã€‚ä¸€ä¸ªèµ„æºå¯èƒ½åªæœ‰ä¸€ä¸ªææ„å‡½æ•°ã€‚

```cadence
var destructorCalled = false

pub resource Resource {

    // Declare a destructor for the resource, which is executed
    // when the resource is destroyed.
    //
    destroy() {
        destructorCalled = true
    }
}

let res <- create Resource()
destroy res
// `destructorCalled` is `true`
```

### åµŒå¥—èµ„æº

å½“å¤åˆç±»å‹ä¸­çš„å­—æ®µå…·æœ‰èµ„æºç±»å‹æ—¶ï¼Œå®ƒä»¬çš„è¡Œä¸ºä¼šæœ‰æ‰€ä¸åŒã€‚

å¦‚æœèµ„æºç±»å‹å…·æœ‰å…·æœ‰èµ„æºç±»å‹çš„å­—æ®µï¼Œåˆ™å®ƒ**å¿…é¡»**å£°æ˜ä¸€ä¸ªææ„å‡½æ•°ï¼Œè¯¥ææ„å‡½æ•°**å¿…é¡»**ä½¿æ‰€æœ‰èµ„æºå­—æ®µæ— æ•ˆï¼Œå³ç§»åŠ¨æˆ–é”€æ¯å®ƒä»¬ã€‚

```cadence
pub resource Child {
    let name: String

    init(name: String)
        self.name = name
    }
}

// Declare a resource with a resource field named `child`.
// The resource *must* declare a destructor
// and the destructor *must* invalidate the resource field.
//
pub resource Parent {
    let name: String
    var child: @Child

    init(name: String, child: @Child) {
        self.name = name
        self.child <- child
    }

    // Declare a destructor which invalidates the resource field
    // `child` by destroying it.
    //
    destroy() {
        destroy self.child
    }
}
```

åœ¨èµ„æºé¢†åŸŸçš„è®¿é—®å­—æ®µæˆ–è°ƒç”¨å‡½æ•°æ˜¯æœ‰æ•ˆçš„ï¼Œä½†æ˜¯ç§»åŠ¨çš„èµ„æºï¼Œå˜é‡èµ„æºé¢†åŸŸæ˜¯**ä¸æ˜¯**å…è®¸ã€‚ç›¸åï¼Œä½¿ç”¨äº¤æ¢è¯­å¥å°†èµ„æºæ›¿æ¢ä¸ºå¦ä¸€ä¸ªèµ„æºã€‚

```cadence
let child <- create Child(name: "Child 1")
let parent <- create Parent(name: "Parent", child: <-child)

child.name  // is "Child 1"
parent.child.name  // is "Child 1"

// Invalid: Cannot move resource out of variable resource field.
let childAgain <- parent.child

// Instead, use a swap statement.
//
var otherChild <- create Child(name: "Child 2")
parent.child <-> otherChild
// `parent.child` is the second child, Child 2.
// `otherChild` is the first child, Child 1.
```

### é—­åŒ…ä¸­çš„èµ„æº

èµ„æºä¸èƒ½åœ¨é—­åŒ…ä¸­æ•è·ï¼Œå› ä¸ºè¿™å¯èƒ½ä¼šå¯¼è‡´é‡å¤ã€‚

```cadence
resource R {}

// Invalid: Declare a function which returns a closure which refers to
// the resource parameter `resource`. Each call to the returned function
// would return the resource, which should not be possible.
//
fun makeCloner(resource: @R): ((): @R) {
    return fun (): @R {
        return <-resource
    }
}

let test = makeCloner(resource: <-create R())
```

### æ•°ç»„å’Œå­—å…¸ä¸­çš„èµ„æº

æ•°ç»„å’Œå­—å…¸çš„è¡Œä¸ºä¸åŒï¼Œå½“å®ƒä»¬åŒ…å«èµ„æºï¼šå®ƒ**ä¸**å…è®¸ç´¢å¼•åˆ°ä¸€ä¸ªæ•°ç»„æ¥è¯»å–åœ¨ç‰¹å®šç´¢å¼•æˆ–åˆ†é…ç»™å®ƒï¼Œæˆ–ç´¢å¼•çš„å…ƒç´ åˆ°ä¸€ä¸ªå­—å…¸æ¥è¯»å–ç‰¹å®šé”®çš„å€¼æˆ–è®¾å®šä¸ºä¸€ä¸ªå€¼é’¥åŒ™ã€‚

ç›¸åï¼Œä½¿ç”¨ swap è¯­å¥ ( `<->`) æˆ– shift è¯­å¥ ( `<- target <-`) å°†è®¿é—®çš„èµ„æºæ›¿æ¢ä¸ºå¦ä¸€ä¸ªèµ„æºã€‚

```cadence
resource R {}

// Declare a constant for an array of resources.
// Create two resources and move them into the array.
// `resources` has type `@[R]`
//
let resources <- [
    <-create R(),
    <-create R()
]

// Invalid: Reading an element from a resource array is not allowed.
//
let firstResource <- resources[0]

// Invalid: Setting an element in a resource array is not allowed,
// as it would result in the loss of the current value.
//
resources[0] <- create R()

// Instead, when attempting to either read an element or update an element
// in a resource array, use a swap statement with a variable to replace
// the accessed element.
//
var res <- create R()
resources[0] <-> res
// `resources[0]` now contains the new resource.
// `res` now contains the old resource.

// Use the shift statement to move the new resource into
// the array at the same time that the old resource is being moved out
let oldRes <- resources[0] <- create R()
// The old object still needs to be handled
destroy oldRes
```

è¿™åŒæ ·é€‚ç”¨äºå­—å…¸ã€‚

```cadence
// Declare a constant for a dictionary of resources.
// Create two resources and move them into the dictionary.
// `resources` has type `@{String: R}`
//
let resources <- {
    "r1": <-create R(),
    "r2": <-create R()
}

// Invalid: Reading an element from a resource dictionary is not allowed.
// It's not obvious that an access like this would have to remove
// the key from the dictionary.
//
let firstResource <- resources["r1"]

// Instead, make the removal explicit by using the `remove` function.
let firstResource <- resources.remove(key: "r1")

// Invalid: Setting an element in a resource dictionary is not allowed,
// as it would result in the loss of the current value.
//
resources["r1"] <- create R()

// Instead, when attempting to either read an element or update an element
// in a resource dictionary, use a swap statement with a variable to replace
// the accessed element.
//
var res <- create R()
resources["r1"] <-> res
// `resources["r1"]` now contains the new resource.
// `res` now contains the old resource.

// Use the shift statement to move the new resource into
// the dictionary at the same time that the old resource is being moved out
let oldRes <- resources["r2"] <- create R()
// The old object still needs to be handled
destroy oldRes
```

èµ„æºä¸èƒ½å¤šæ¬¡ç§»åŠ¨åˆ°æ•°ç»„å’Œå­—å…¸ä¸­ï¼Œå› ä¸ºè¿™ä¼šå¯¼è‡´é‡å¤ã€‚

```cadence
let resource <- create R()

// Invalid: The resource variable `resource` can only be moved into the array once.
//
let resources <- [
    <-resource,
    <-resource
]
```

```cadence
let resource <- create R()

// Invalid: The resource variable `resource` can only be moved into the dictionary once.
let resources <- {
    "res1": <-resource,
    "res2": <-resource
}
```

èµ„æºæ•°ç»„å’Œå­—å…¸å¯ä»¥è¢«é”€æ¯ã€‚

```cadence
let resources <- [
    <-create R(),
    <-create R()
]
destroy resources
```

```cadence
let resources <- {
    "r1": <-create R(),
    "r2": <-create R()
}
destroy resources
```

å˜é‡æ•°ç»„çš„åŠŸèƒ½ç±»ä¼¼äº`append`, `insert`ï¼Œå¹¶ä¸”å…¶`remove` è¡Œä¸ºç±»ä¼¼äºéèµ„æºæ•°ç»„ã€‚ä½†æ˜¯è¯·æ³¨æ„ï¼Œ`remove`å¿…é¡»ä½¿ç”¨å‡½æ•°çš„ç»“æœã€‚

```cadence
let resources <- [<-create R()]
// `resources.length` is `1`

resources.append(<-create R())
// `resources.length` is `2`

let first <- resource.remove(at: 0)
// `resources.length` is `1`
destroy first

resources.insert(at: 0, <-create R())
// `resources.length` is `2`

// Invalid: The statement ignores the result of the call to `remove`,
// which would result in a loss.
resource.remove(at: 0)

destroy resources
```

å¯å˜æ•°ç»„å‡½æ•°`contains`ä¸å¯ç”¨ï¼Œå› ä¸ºå®ƒæ˜¯ä¸å¯èƒ½çš„ï¼šå¦‚æœèµ„æºå¯ä»¥ä¼ é€’ç»™`contains`å‡½æ•°ï¼Œåˆ™æ ¹æ®å®šä¹‰ï¼Œå®ƒä¸åœ¨æ•°ç»„ä¸­ã€‚

å˜é‡æ•°ç»„åŠŸèƒ½`concat`ä¸å¯ç”¨ï¼Œå› ä¸ºå®ƒä¼šå¯¼è‡´èµ„æºé‡å¤ã€‚

å­—å…¸çš„åŠŸèƒ½`insert`å’Œ`remove` è¡Œä¸ºç±»ä¼¼äºéèµ„æºå­—å…¸ã€‚ä½†æ˜¯è¯·æ³¨æ„ï¼Œå¿…é¡»ä½¿ç”¨è¿™äº›å‡½æ•°çš„ç»“æœã€‚

```cadence
let resources <- {"r1": <-create R()}
// `resources.length` is `1`

let first <- resource.remove(key: "r1")
// `resources.length` is `0`
destroy first

let old <- resources.insert(key: "r1", <-create R())
// `old` is nil, as there was no value for the key "r1"
// `resources.length` is `1`

let old2 <- resources.insert(key: "r1", <-create R())
// `old2` is the old value for the key "r1"
// `resources.length` is `1`

destroy old
destroy old2
destroy resources
```

### èµ„æºæ ‡è¯†ç¬¦

èµ„æºæœ‰ä¸€ä¸ªä¸ä¹‹å…³è”çš„éšå¼å”¯ä¸€æ ‡è¯†ç¬¦ï¼Œç”±`let uuid: UInt64`æ¯ä¸ªèµ„æºä¸Šé¢„å…ˆå£°æ˜çš„å…¬å…±å­—æ®µå®ç°ã€‚

è¿™ä¸ªæ ‡è¯†ç¬¦ä¼šåœ¨èµ„æºåˆ›å»ºæ—¶è‡ªåŠ¨è®¾ç½®ï¼Œåœ¨èµ„æºçš„åˆå§‹åŒ–ç¨‹åºè¢«è°ƒç”¨ä¹‹å‰ï¼ˆå³æ ‡è¯†ç¬¦å¯ä»¥åœ¨åˆå§‹åŒ–ç¨‹åºä¸­ä½¿ç”¨ï¼‰ï¼Œå¹¶ä¸”å³ä½¿åœ¨èµ„æºè¢«é”€æ¯åä¹Ÿæ˜¯å”¯ä¸€çš„ï¼Œå³æ²¡æœ‰ä¸¤ä¸ªèµ„æºä¼šå…·æœ‰ç›¸åŒçš„æ ‡è¯†ç¬¦ã€‚

```cadence
// Declare a resource without any fields.
resource R {}

// Create two resources
let r1 <- create R()
let r2 <- create R()

// Get each resource's unique identifier
let id1 = r1.uuid
let id2 = r2.uuid

// Destroy the first resource
destroy r1

// Create a third resource
let r3 <- create R()

let id3 = r3.uuid

id1 != id2  // true
id2 != id3  // true
id3 != id1  // true
```

å¦‚ä½•ç”Ÿæˆæ ‡è¯†ç¬¦çš„ç»†èŠ‚æ˜¯ä¸€ä¸ªå®ç°ç»†èŠ‚ã€‚

ä¸è¦ä¾èµ–æˆ–å‡è®¾ Cadence ç¨‹åºä¸­çš„ä»»ä½•ç‰¹å®šè¡Œä¸ºã€‚

## æœªç»‘å®šå¼•ç”¨/ç©ºå€¼

æœ‰**æ²¡æœ‰**æ”¯æŒ`null`ã€‚

## ç»§æ‰¿å’ŒæŠ½è±¡ç±»å‹

æœ‰**æ²¡æœ‰**æ”¯æŒç»§æ‰¿ã€‚ç»§æ‰¿æ˜¯å…¶ä»–ç¼–ç¨‹è¯­è¨€ä¸­å¸¸è§çš„ç‰¹æ€§ï¼Œå®ƒå…è®¸å°†ä¸€ç§ç±»å‹çš„å­—æ®µå’Œå‡½æ•°åŒ…å«åœ¨å¦ä¸€ç§ç±»å‹ä¸­ã€‚

ç›¸åï¼Œéµå¾ªâ€œç»„åˆä¼˜äºç»§æ‰¿â€çš„åŸåˆ™ï¼Œå³ä»å¤šä¸ªå•ç‹¬çš„éƒ¨åˆ†ç»„åˆåŠŸèƒ½çš„æƒ³æ³•ï¼Œè€Œä¸æ˜¯æ„å»ºç»§æ‰¿æ ‘ã€‚

æ­¤å¤–ï¼Œ**ä¹Ÿä¸**æ”¯æŒæŠ½è±¡ç±»å‹ã€‚æŠ½è±¡ç±»å‹æ˜¯å…¶ä»–ç¼–ç¨‹è¯­è¨€ä¸­å¸¸è§çš„ç‰¹æ€§ï¼Œå®ƒé˜»æ­¢åˆ›å»ºç±»å‹çš„å€¼ï¼Œåªå…è®¸åˆ›å»ºå­ç±»å‹çš„å€¼ã€‚æ­¤å¤–ï¼ŒæŠ½è±¡ç±»å‹å¯ä»¥å£°æ˜å‡½æ•°ï¼Œä½†çœç•¥äº†å®ƒä»¬çš„å®ç°ï¼Œè€Œæ˜¯éœ€è¦å­ç±»å‹æ¥å®ç°å®ƒä»¬ã€‚

ç›¸åï¼Œè¯·è€ƒè™‘ä½¿ç”¨[æ¥å£](https://docs.onflow.org/cadence/language/interfaces)ã€‚