# æ¥å£

------

æ¥å£æ˜¯ä¸€ç§æŠ½è±¡ç±»å‹ï¼Œå®ƒæŒ‡å®š*å®ç°*æ¥å£çš„ç±»å‹çš„è¡Œä¸ºã€‚æ¥å£å£°æ˜æ‰€éœ€çš„å‡½æ•°å’Œå­—æ®µã€è¿™äº›å£°æ˜çš„è®¿é—®æ§åˆ¶ä»¥åŠå®ç°ç±»å‹éœ€è¦æä¾›çš„å‰ç½®æ¡ä»¶å’Œåç½®æ¡ä»¶ã€‚

å…±æœ‰ä¸‰ç§æ¥å£ï¼š

- **ç»“æ„æ¥å£**ï¼šç”±[ç»“æ„](https://docs.onflow.org/cadence/language/composite-types#structures)å®ç°
- **èµ„æºæ¥å£**ï¼šç”±[èµ„æº](https://docs.onflow.org/cadence/language/composite-types#resources)å®ç°
- **åˆçº¦æ¥å£**ï¼šç”±[åˆçº¦](https://docs.onflow.org/cadence/language/contracts)å®ç°

ç»“æ„ã€èµ„æºå’Œå¥‘çº¦ç±»å‹å¯ä»¥å®ç°å¤šä¸ªæ¥å£ã€‚

ä¸æ”¯æŒäº‹ä»¶å’Œæšä¸¾æ¥å£ã€‚

åä¹‰ç±»å‹é€‚ç”¨äºå®ç°æ¥å£çš„å¤åˆç±»å‹ã€‚è¿™æ„å‘³ç€ä¸€ä¸ªç±»å‹åªæœ‰åœ¨æ˜¾å¼å£°æ˜äº†ä¸€è‡´æ€§çš„æƒ…å†µä¸‹æ‰å®ç°æ¥å£ï¼Œå¤åˆç±»å‹ä¸ä¼šéšå¼åœ°ç¬¦åˆæ¥å£ï¼Œå³ä½¿å®ƒæ»¡è¶³æ¥å£çš„æ‰€æœ‰è¦æ±‚ã€‚

æ¥å£ç”±å®ç°æ¥å£çš„ç±»å‹å¿…é¡»ä¸ºå…¶æä¾›å®ç°çš„åŠŸèƒ½å’Œå­—æ®µè¦æ±‚ç»„æˆã€‚æ¥å£è¦æ±‚åŠå…¶å®ç°å¿…é¡»å§‹ç»ˆè‡³å°‘æ˜¯å…¬å¼€çš„ã€‚

å¯ä»¥å¯¹å¯å˜å­—æ®µè¦æ±‚è¿›è¡Œæ³¨é‡Šä»¥è¦æ±‚å®ƒä»¬å¯å…¬å¼€è®¾ç½®ã€‚

å‡½æ•°è¦æ±‚åŒ…æ‹¬å‡½æ•°åç§°ã€å‚æ•°ç±»å‹ã€å¯é€‰çš„è¿”å›ç±»å‹ä»¥åŠå¯é€‰çš„å‰ç½®æ¡ä»¶å’Œåç½®æ¡ä»¶ã€‚

å­—æ®µè¦æ±‚åŒ…æ‹¬å­—æ®µçš„åç§°å’Œç±»å‹ã€‚å­—æ®µéœ€æ±‚å¯ä»¥é€‰æ‹©å£°æ˜ä¸€ä¸ª getter éœ€æ±‚å’Œä¸€ä¸ª setter éœ€æ±‚ï¼Œæ¯ä¸ªéœ€æ±‚éƒ½æœ‰å‰ç½®æ¡ä»¶å’Œåç½®æ¡ä»¶ã€‚

åœ¨æ¥å£ä¸Šè°ƒç”¨å…·æœ‰å‰ç½®æ¡ä»¶å’Œåç½®æ¡ä»¶è€Œä¸æ˜¯å…·ä½“å®ç°çš„å‡½æ•°å¯ä»¥æé«˜ç¨‹åºçš„å®‰å…¨æ€§ï¼Œå› ä¸ºå®ƒç¡®ä¿å³ä½¿å®ç°å‘ç”Ÿå˜åŒ–ï¼Œå®ƒä»¬çš„æŸäº›æ–¹é¢ä¹Ÿå°†å§‹ç»ˆä¿æŒä¸å˜ã€‚

## æ¥å£å£°æ˜

æ¥å£æ‰€ä½¿ç”¨çš„å£°æ˜`struct`ï¼Œ`resource`æˆ–`contract`å…³é”®å­—ï¼Œå…¶æ¬¡æ˜¯`interface`å…³é”®å­—æ—¶ï¼Œæ¥å£çš„åç§°ï¼Œå’Œçš„è¦æ±‚ï¼Œå…¶å¿…é¡»å°è£…åœ¨å¼€é—­æ‹¬å·ã€‚

é€šè¿‡ä½¿ç”¨`var`å…³é”®å­—ï¼Œå¯ä»¥æ³¨é‡Šå­—æ®µè¦æ±‚ä»¥è¦æ±‚å®ç°æ˜¯å¯å˜å­—æ®µï¼›é€šè¿‡ä½¿ç”¨`let`å…³é”®å­—ï¼Œè¦æ±‚å®ç°æ˜¯ä¸€ä¸ªå¸¸é‡å­—æ®µï¼›æˆ–è€…å­—æ®µè¦æ±‚å¯ä»¥ä¸æŒ‡å®šä»»ä½•å†…å®¹ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®ç°å¯ä»¥æ˜¯å¯å˜å­—æ®µã€å¸¸é‡å­—æ®µæˆ–åˆæˆå­—æ®µã€‚

å­—æ®µè¦æ±‚å’ŒåŠŸèƒ½è¦æ±‚å¿…é¡»æŒ‡å®šæ‰€éœ€çš„è®¿é—®çº§åˆ«ã€‚è®¿é—®å¿…é¡»è‡³å°‘æ˜¯å…¬å¼€çš„ï¼Œå› æ­¤`pub`å¿…é¡»æä¾›å…³é”®å­—ã€‚å¯ä»¥ä½¿ç”¨`pub(set)`å…³é”®å­—å°†å˜é‡å­—æ®µè¦æ±‚æŒ‡å®šä¸ºä¹Ÿå¯ä»¥å…¬å¼€è®¾ç½®ã€‚

æ¥å£å¯ä»¥åœ¨ç±»å‹ä¸­ä½¿ç”¨ã€‚è¿™[åœ¨ç±»å‹](https://docs.onflow.org/cadence/language/interfaces/#interfaces-in-types)ä¸­çš„[æ¥å£](https://docs.onflow.org/cadence/language/interfaces/#interfaces-in-types)éƒ¨åˆ†ä¸­æœ‰è¯¦ç»†è§£é‡Šã€‚ç›®å‰ï¼Œè¯­æ³•`{I}`å¯ä»¥ç†è§£ä¸ºå®ç° interface çš„ä»»ä½•å€¼çš„ç±»å‹`I`ã€‚

```cadence
// Declare a resource interface for a fungible token.
// Only resources can implement this resource interface.
//
pub resource interface FungibleToken {

    // Require the implementing type to provide a field for the balance
    // that is readable in all scopes (`pub`).
    //
    // Neither the `var` keyword, nor the `let` keyword is used,
    // so the field may be implemented as either a variable field,
    // a constant field, or a synthetic field.
    //
    // The read balance must always be positive.
    //
    // NOTE: no requirement is made for the kind of field,
    // it can be either variable or constant in the implementation.
    //
    pub balance: Int {
        set(newBalance) {
            pre {
                newBalance >= 0:
                    "Balances are always set as non-negative numbers"
            }
        }
    }

    // Require the implementing type to provide an initializer that
    // given the initial balance, must initialize the balance field.
    //
    init(balance: Int) {
        pre {
            balance >= 0:
                "Balances are always non-negative"
        }
        post {
            self.balance == balance:
                "the balance must be initialized to the initial balance"
        }

        // NOTE: The declaration contains no implementation code.
    }

    // Require the implementing type to provide a function that is
    // callable in all scopes, which withdraws an amount from
    // this fungible token and returns the withdrawn amount as
    // a new fungible token.
    //
    // The given amount must be positive and the function implementation
    // must add the amount to the balance.
    //
    // The function must return a new fungible token.
    // The type `{FungibleToken}` is the type of any resource
    // that implements the resource interface `FungibleToken`.
    //
    pub fun withdraw(amount: Int): @{FungibleToken} {
        pre {
            amount > 0:
                "the amount must be positive"
            amount <= self.balance:
                "insufficient funds: the amount must be smaller or equal to the balance"
        }
        post {
            self.balance == before(self.balance) - amount:
                "the amount must be deducted from the balance"
        }

        // NOTE: The declaration contains no implementation code.
    }

    // Require the implementing type to provide a function that is
    // callable in all scopes, which deposits a fungible token
    // into this fungible token.
    //
    // No precondition is required to check the given token's balance
    // is positive, as this condition is already ensured by
    // the field requirement.
    //
    // The parameter type `{FungibleToken}` is the type of any resource
    // that implements the resource interface `FungibleToken`.
    //
    pub fun deposit(_ token: @{FungibleToken}) {
        post {
            self.balance == before(self.balance) + token.balance:
                "the amount must be added to the balance"
        }

        // NOTE: The declaration contains no implementation code.
    }
}
```

è¯·æ³¨æ„ï¼Œæ‰€éœ€çš„åˆå§‹åŒ–ç¨‹åºå’Œå‡½æ•°æ²¡æœ‰ä»»ä½•å¯æ‰§è¡Œä»£ç ã€‚

ç»“æ„å’Œèµ„æºæ¥å£åªèƒ½ç›´æ¥åœ¨å¥‘çº¦å†…éƒ¨å£°æ˜ï¼Œå³ä¸èƒ½åœ¨å‡½æ•°å†…éƒ¨å£°æ˜ã€‚åˆçº¦æ¥å£åªèƒ½å…¨å±€å£°æ˜ï¼Œä¸èƒ½åœ¨åˆçº¦å†…éƒ¨å£°æ˜ã€‚

## æ¥å£å®ç°

å£°æ˜ç±»å‹å®ç°ï¼ˆç¬¦åˆï¼‰æ¥å£æ˜¯åœ¨å¤åˆç±»å‹ï¼ˆä¾‹å¦‚ï¼Œç»“æ„ã€èµ„æºï¼‰çš„ç±»å‹å£°æ˜ä¸­å®Œæˆçš„ï¼šå¤åˆç±»å‹çš„ç§ç±»å’Œåç§°åè·Ÿå†’å· ( `:`) å’Œä¸€ä¸ªçš„åç§°æˆ–å¤åˆç±»å‹å®ç°çš„æ›´å¤šæ¥å£ã€‚

è¿™å°†å‘Šè¯‰æ£€æŸ¥å™¨å°†æ¥è‡ªæŒ‡å®šæ¥å£çš„ä»»ä½•è¦æ±‚å¼ºåˆ¶æ‰§è¡Œåˆ°å£°æ˜çš„ç±»å‹ä¸Šã€‚

ä¸€ä¸ªç±»å‹å®ç°ï¼ˆç¬¦åˆï¼‰ä¸€ä¸ªæ¥å£ï¼Œå¦‚æœå®ƒåœ¨å…¶ç­¾åä¸­å£°æ˜å®ç°ï¼Œä¸ºæ¥å£æ‰€éœ€çš„æ‰€æœ‰å­—æ®µæä¾›å­—æ®µå£°æ˜ï¼Œå¹¶ä¸ºæ¥å£æ‰€éœ€çš„æ‰€æœ‰åŠŸèƒ½æä¾›å®ç°ã€‚

å®ç°ç±»å‹ä¸­çš„å­—æ®µå£°æ˜å¿…é¡»åœ¨åç§°ã€ç±»å‹å’Œå£°æ˜ç±»å‹ï¼ˆä¾‹å¦‚å¸¸é‡ã€å˜é‡ï¼‰æ–¹é¢ä¸æ¥å£ä¸­çš„å­—æ®µè¦æ±‚ç›¸åŒ¹é…ï¼ˆå¦‚æœç»™å®šï¼‰ã€‚ä¾‹å¦‚ï¼Œæ¥å£å¯èƒ½éœ€è¦å…·æœ‰ç‰¹å®šåç§°å’Œç±»å‹çš„å­—æ®µï¼Œä½†å°†å­—æ®µçš„ç±»å‹ç•™ç»™å®ç°ã€‚

å‡½æ•°å®ç°å¿…é¡»åœ¨åç§°ã€å‚æ•°å‚æ•°æ ‡ç­¾ã€å‚æ•°ç±»å‹å’Œè¿”å›ç±»å‹æ–¹é¢ä¸æ¥å£ä¸­çš„å‡½æ•°è¦æ±‚ç›¸åŒ¹é…ã€‚

```cadence
// Declare a resource named `ExampleToken` that has to implement
// the `FungibleToken` interface.
//
// It has a variable field named `balance`, that can be written
// by functions of the type, but outer scopes can only read it.
//
pub resource ExampleToken: FungibleToken {

    // Implement the required field `balance` for the `FungibleToken` interface.
    // The interface does not specify if the field must be variable, constant,
    // so in order for this type (`ExampleToken`) to be able to write to the field,
    // but limit outer scopes to only read from the field, it is declared variable,
    // and only has public access (non-settable).
    //
    pub var balance: Int

    // Implement the required initializer for the `FungibleToken` interface:
    // accept an initial balance and initialize the `balance` field.
    //
    // This implementation satisfies the required postcondition.
    //
    // NOTE: the postcondition declared in the interface
    // does not have to be repeated here in the implementation.
    //
    init(balance: Int) {
        self.balance = balance
    }

    // Implement the required function named `withdraw` of the interface
    // `FungibleToken`, that withdraws an amount from the token's balance.
    //
    // The function must be public.
    //
    // This implementation satisfies the required postcondition.
    //
    // NOTE: neither the precondition nor the postcondition declared
    // in the interface have to be repeated here in the implementation.
    //
    pub fun withdraw(amount: Int): @ExampleToken {
        self.balance = self.balance - amount
        return create ExampleToken(balance: amount)
    }

    // Implement the required function named `deposit` of the interface
    // `FungibleToken`, that deposits the amount from the given token
    // to this token.
    //
    // The function must be public.
    //
    // NOTE: the type of the parameter is `{FungibleToken}`,
    // i.e., any resource that implements the resource interface `FungibleToken`,
    // so any other token â€“ however, we want to ensure that only tokens
    // of the same type can be deposited.
    //
    // This implementation satisfies the required postconditions.
    //
    // NOTE: neither the precondition nor the postcondition declared
    // in the interface have to be repeated here in the implementation.
    //
    pub fun deposit(_ token: @{FungibleToken}) {
        if let exampleToken <- token as? ExampleToken {
            self.balance = self.balance + exampleToken.balance
            destroy exampleToken
        } else {
            panic("cannot deposit token which is not an example token")
        }
    }
}

// Declare a constant which has type `ExampleToken`,
// and is initialized with such an example token.
//
let token <- create ExampleToken(balance: 100)

// Withdraw 10 units from the token.
//
// The amount satisfies the precondition of the `withdraw` function
// in the `FungibleToken` interface.
//
// Invoking a function of a resource does not destroy the resource,
// so the resource `token` is still valid after the call of `withdraw`.
//
let withdrawn <- token.withdraw(amount: 10)

// The postcondition of the `withdraw` function in the `FungibleToken`
// interface ensured the balance field of the token was updated properly.
//
// `token.balance` is `90`
// `withdrawn.balance` is `10`

// Deposit the withdrawn token into another one.
let receiver: @ExampleToken <- // ...
receiver.deposit(<-withdrawn)

// Run-time error: The precondition of function `withdraw` in interface
// `FungibleToken` fails, the program aborts: the parameter `amount`
// is larger than the field `balance` (100 > 90).
//
token.withdraw(amount: 100)

// Withdrawing tokens so that the balance is zero does not destroy the resource.
// The resource has to be destroyed explicitly.
//
token.withdraw(amount: 90)
```

å®ç°ä¸­å˜é‡å­—æ®µçš„è®¿é—®çº§åˆ«å¯èƒ½æ¯”æ¥å£è¦æ±‚çš„é™åˆ¶æ›´å°‘ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªæ¥å£å¯èƒ½è¦æ±‚ä¸€ä¸ªå­—æ®µè‡³å°‘æ˜¯å…¬å¼€çš„ï¼ˆå³`pub`æŒ‡å®šå…³é”®å­—ï¼‰ï¼Œè€Œä¸€ä¸ªå®ç°å¯ä»¥æä¾›ä¸€ä¸ªå…¬å…±çš„å˜é‡å­—æ®µï¼Œä½†ä¹Ÿå¯ä»¥å…¬å¼€è®¾ç½®ï¼ˆ`pub(set)`æŒ‡å®šå…³é”®å­—ï¼‰ã€‚

```cadence
pub struct interface AnInterface {
    // Require the implementing type to provide a publicly readable
    // field named `a` that has type `Int`. It may be a constant field,
    // a variable field, or a synthetic field.
    //
    pub a: Int
}

pub struct AnImplementation: AnInterface {
    // Declare a publicly settable variable field named `a` that has type `Int`.
    // This implementation satisfies the requirement for interface `AnInterface`:
    // The field is at least publicly readable, but this implementation also
    // allows the field to be written to in all scopes.
    //
    pub(set) var a: Int

    init(a: Int) {
        self.a = a
    }
}
```

## ç±»å‹ä¸­çš„æ¥å£

æ¥å£å¯ä»¥åœ¨ç±»å‹ä¸­ä½¿ç”¨ï¼šç±»å‹`{I}`æ˜¯å®ç°æ¥å£çš„æ‰€æœ‰å¯¹è±¡çš„ç±»å‹`I`ã€‚

è¿™ç§°ä¸º[å—é™ç±»å‹](https://docs.onflow.org/cadence/language/restricted-types)ï¼šè®¿é—®æ­¤ç±»ç±»å‹çš„å€¼æ—¶ï¼Œåªèƒ½ä½¿ç”¨æ¥å£çš„åŠŸèƒ½ï¼ˆæˆå‘˜å’Œå‡½æ•°ï¼‰ã€‚

```cadence
// Declare an interface named `Shape`.
//
// Require implementing types to provide a field which returns the area,
// and a function which scales the shape by a given factor.
//
pub struct interface Shape {
    pub fun getArea(): Int
    pub fun scale(factor: Int)
}

// Declare a structure named `Square` the implements the `Shape` interface.
//
pub struct Square: Shape {
    // In addition to the required fields from the interface,
    // the type can also declare additional fields.
    //
    pub var length: Int

    // Provided the field `area`  which is required to conform
    // to the interface `Shape`.
    //
    // Since `area` was not declared as a constant, variable,
    // field in the interface, it can be declared.
    //
    pub fun getArea(): Int {
        return self.length * self.length
    }

    pub init(length: Int) {
        self.length = length
    }

    // Provided the implementation of the function `scale`
    // which is required to conform to the interface `Shape`.
    //
    pub fun scale(factor: Int) {
        self.length = self.length * factor
    }
}

// Declare a structure named `Rectangle` that also implements the `Shape` interface.
//
pub struct Rectangle: Shape {
    pub var width: Int
    pub var height: Int

    // Provided the field `area  which is required to conform
    // to the interface `Shape`.
    //
    pub fun getArea(): Int {
        return self.width * self.height
    }

    pub init(width: Int, height: Int) {
        self.width = width
        self.height = height
    }

    // Provided the implementation of the function `scale`
    // which is required to conform to the interface `Shape`.
    //
    pub fun scale(factor: Int) {
        self.width = self.width * factor
        self.height = self.height * factor
    }
}

// Declare a constant that has type `Shape`, which has a value that has type `Rectangle`.
//
var shape: {Shape} = Rectangle(width: 10, height: 20)
```

å®ç°æ¥å£çš„å€¼å¯åˆ†é…ç»™ä»¥æ¥å£ä½œä¸ºå…¶ç±»å‹çš„å˜é‡ã€‚

```cadence
// Assign a value of type `Square` to the variable `shape` that has type `Shape`.
//
shape = Square(length: 30)

// Invalid: cannot initialize a constant that has type `Rectangle`.
// with a value that has type `Square`.
//
let rectangle: Rectangle = Square(length: 10)
```

å¯ä»¥è®¿é—®æ¥å£ä¸­å£°æ˜çš„å­—æ®µï¼Œå¹¶ä¸”å¯ä»¥å¯¹å®ç°è¯¥æ¥å£çš„ç±»å‹çš„å€¼è°ƒç”¨æ¥å£ä¸­å£°æ˜çš„å‡½æ•°ã€‚

```cadence
// Declare a constant which has the type `Shape`.
// and is initialized with a value that has type `Rectangle`.
//
let shape: {Shape} = Rectangle(width: 2, height: 3)

// Access the field `area` declared in the interface `Shape`.
//
shape.area  // is `6`

// Call the function `scale` declared in the interface `Shape`.
//
shape.scale(factor: 3)

shape.area  // is `54`
```

## æ¥å£å®ç°è¦æ±‚

æ¥å£å¯èƒ½éœ€è¦å®ç°ç±»å‹æ¥å®ç°å…¶ä»–åŒç±»æ¥å£ã€‚æ¥å£å®ç°éœ€æ±‚å¯ä»¥é€šè¿‡åœ¨æ¥å£åç§°ååŠ å†’å·ï¼ˆ`:`ï¼‰å’Œä¸€ä¸ªæˆ–å¤šä¸ªåŒç±»æ¥å£åç§°æ¥å£°æ˜ï¼Œç”¨é€—å·éš”å¼€ã€‚

```cadence
// Declare a structure interface named `Shape`.
//
pub struct interface Shape {}

// Declare a structure interface named `Polygon`.
// Require implementing types to also implement the structure interface `Shape`.
//
pub struct interface Polygon: Shape {}

// Declare a structure named `Hexagon` that implements the `Polygon` interface.
// This also is required to implement the `Shape` interface,
// because the `Polygon` interface requires it.
//
pub struct Hexagon: Polygon {}
```

## æ¥å£åµŒå¥—

ğŸš§ çŠ¶æ€ï¼šç›®å‰åªæœ‰åˆçº¦å’Œåˆçº¦æ¥å£æ”¯æŒåµŒå¥—æ¥å£ã€‚

æ¥å£å¯ä»¥ä»»æ„åµŒå¥—ã€‚åœ¨å¦ä¸€ä¸ªå†…éƒ¨å£°æ˜ä¸€ä¸ªæ¥å£ä¸éœ€è¦å®ç°å¤–éƒ¨æ¥å£çš„ç±»å‹æ¥æä¾›å†…éƒ¨æ¥å£çš„å®ç°ã€‚

```cadence
// Declare a resource interface `OuterInterface`, which declares
// a nested structure interface named `InnerInterface`.
//
// Resources implementing `OuterInterface` do not need to provide
// an implementation of `InnerInterface`.
//
// Structures may just implement `InnerInterface`.
//
resource interface OuterInterface {

    struct interface InnerInterface {}
}

// Declare a resource named `SomeOuter` that implements the interface `OuterInterface`
//
// The resource is not required to implement `OuterInterface.InnerInterface`.
//
resource SomeOuter: OuterInterface {}

// Declare a structure named `SomeInner` that implements `InnerInterface`,
// which is nested in interface `OuterInterface`.
//
struct SomeInner: OuterInterface.InnerInterface {}
```

## åµŒå¥—ç±»å‹è¦æ±‚

ğŸš§ çŠ¶æ€ï¼šç›®å‰åªæœ‰å¥‘çº¦å’Œå¥‘çº¦æ¥å£æ”¯æŒåµŒå¥—ç±»å‹éœ€æ±‚ã€‚

æ¥å£å¯èƒ½éœ€è¦å®ç°ç±»å‹ä»¥æä¾›å…·ä½“çš„åµŒå¥—ç±»å‹ã€‚ä¾‹å¦‚ï¼Œèµ„æºæ¥å£å¯èƒ½éœ€è¦ä¸€ä¸ªå®ç°ç±»å‹æ¥æä¾›èµ„æºç±»å‹ã€‚

```cadence
// Declare a resource interface named `FungibleToken`.
//
// Require implementing types to provide a resource type named `Vault`
// which must have a field named `balance`.
//
resource interface FungibleToken {

    pub resource Vault {
        pub balance: Int
    }
}

// Declare a resource named `ExampleToken` that implements the `FungibleToken` interface.
//
// The nested type `Vault` must be provided to conform to the interface.
//
resource ExampleToken: FungibleToken {

    pub resource Vault {
        pub var balance: Int

        init(balance: Int) {
            self.balance = balance
        }
    }
}
```

## `Equatable` ç•Œé¢

ğŸš§ çŠ¶æ€ï¼š`Equatable`æ¥å£å°šæœªå®ç°ã€‚

ç›¸ç­‰ç±»å‹æ˜¯å¯ä»¥æ¯”è¾ƒç›¸ç­‰æ€§çš„ç±»å‹ã€‚ç±»å‹åœ¨å®ç°`Equatable`æ¥å£æ—¶æ˜¯ç›¸ç­‰çš„ã€‚

å¯ä»¥ä½¿ç”¨ç­‰äºè¿ç®—ç¬¦ ( `==`)æ¯”è¾ƒå¯ç›¸ç­‰ç±»å‹çš„ç›¸ç­‰æ€§æˆ–ä½¿ç”¨ä¸ç­‰äºè¿ç®—ç¬¦ ( ) æ¯”è¾ƒä¸ç­‰å¼`!=`ã€‚

å¤§å¤šæ•°å†…ç½®ç±»å‹éƒ½æ˜¯ç­‰ä»·çš„ï¼Œå¦‚å¸ƒå°”å€¼å’Œæ•´æ•°ã€‚å½“æ•°ç»„çš„å…ƒç´ å¯ç›¸ç­‰æ—¶ï¼Œæ•°ç»„æ˜¯å¯ç›¸ç­‰çš„ã€‚å½“å­—å…¸çš„å€¼ç›¸ç­‰æ—¶ï¼Œå­—å…¸æ˜¯ç›¸ç­‰çš„ã€‚

ä¸ºäº†ä½¿ç±»å‹ç›¸ç­‰ï¼Œ`Equatable`å¿…é¡»å®ç°æ¥å£ï¼Œè¿™éœ€è¦å®ç° function `equals`ï¼Œå®ƒæ¥å—å¦ä¸€ä¸ªå€¼ï¼Œåº”è¯¥æ¯”è¾ƒç»™å®šçš„å€¼æ˜¯å¦ç›¸ç­‰ã€‚

```cadence
struct interface Equatable {
    pub fun equals(_ other: {Equatable}): Bool
}
```

```cadence
// Declare a struct named `Cat`, which has one field named `id`
// that has type `Int`, i.e., the identifier of the cat.
//
// `Cat` also will implement the interface `Equatable`
// to allow cats to be compared for equality.
//
struct Cat: Equatable {
    pub let id: Int

    init(id: Int) {
        self.id = id
    }

    pub fun equals(_ other: {Equatable}): Bool {
        if let otherCat = other as? Cat {
            // Cats are equal if their identifier matches.
            //
            return otherCat.id == self.id
        } else {
            return false
        }
    }
}

Cat(1) == Cat(2)  // is `false`
Cat(3) == Cat(3)  // is `true`
```

## `Hashable` ç•Œé¢

ğŸš§ çŠ¶æ€ï¼š`Hashable`æ¥å£å°šæœªå®ç°ã€‚

å¯æ•£åˆ—ç±»å‹æ˜¯å¯ä»¥æ•£åˆ—ä¸ºæ•´æ•°æ•£åˆ—å€¼çš„ç±»å‹ï¼Œå³ï¼Œå°†å…¶æç‚¼ä¸ºç”¨ä½œä¸ç­‰å¼è¯æ®çš„å€¼ã€‚ç±»å‹åœ¨å®ç°`Hashable`æ¥å£æ—¶æ˜¯å¯æ•£åˆ—çš„ã€‚

å¯æ•£åˆ—ç±»å‹å¯ä»¥ç”¨ä½œå­—å…¸ä¸­çš„é”®ã€‚

å¯æ•£åˆ—ç±»å‹ä¹Ÿå¿…é¡»æ˜¯å¯ç­‰åŒçš„ï¼Œå³å®ƒä»¬è¿˜å¿…é¡»å®ç°`Equatable`æ¥å£ã€‚è¿™æ˜¯å› ä¸ºå“ˆå¸Œå€¼åªæ˜¯ä¸ç­‰å¼çš„è¯æ®ï¼šå…·æœ‰ä¸åŒå“ˆå¸Œå€¼çš„ä¸¤ä¸ªå€¼ä¿è¯ä¸ç›¸ç­‰ã€‚ä½†æ˜¯ï¼Œå¦‚æœä¸¤ä¸ªå€¼çš„å“ˆå¸Œå€¼ç›¸åŒï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªå€¼ä»ç„¶å¯èƒ½ä¸ç›¸ç­‰ï¼Œå¹¶ä¸”æ°å¥½æ•£åˆ—åˆ°ç›¸åŒçš„å“ˆå¸Œå€¼ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä»ç„¶éœ€è¦é€šè¿‡ç›¸ç­‰æ€§æ£€æŸ¥æ¥ç¡®å®šç›¸ç­‰æ€§ã€‚å¦‚æœæ²¡æœ‰`Equatable`ï¼Œå¯ä»¥å°†å€¼æ·»åŠ åˆ°å­—å…¸ä¸­ï¼Œä½†æ— æ³•æ£€ç´¢å®ƒä»¬ã€‚

å¤§å¤šæ•°å†…ç½®ç±»å‹éƒ½æ˜¯å¯æ•£åˆ—çš„ï¼Œå¦‚å¸ƒå°”å€¼å’Œæ•´æ•°ã€‚å½“æ•°ç»„çš„å…ƒç´ æ˜¯å¯æ•£åˆ—çš„æ—¶ï¼Œæ•°ç»„æ˜¯å¯æ•£åˆ—çš„ã€‚å½“å­—å…¸çš„å€¼ç›¸ç­‰æ—¶ï¼Œå­—å…¸æ˜¯å¯æ•£åˆ—çš„ã€‚

æ•£åˆ—å€¼æ„å‘³ç€å°†å…¶åŸºæœ¬ç»„ä»¶ä¼ é€’åˆ°æ•£åˆ—å‡½æ•°ä¸­ã€‚åŸºæœ¬ç»„ä»¶æ˜¯åœ¨`Equatable`.

å¦‚æœä¸¤ä¸ªå€¼ç›¸ç­‰ï¼Œå› ä¸ºå®ƒä»¬çš„`equals`å‡½æ•°è¿”å› trueï¼Œé‚£ä¹ˆå®ç°å¿…é¡»ä¸ºè¿™ä¸¤ä¸ªå€¼ä¸­çš„æ¯ä¸€ä¸ªè¿”å›ç›¸åŒçš„æ•´æ•°å“ˆå¸Œå€¼ã€‚

å½“åŸºæœ¬ç»„ä»¶æ²¡æœ‰æ”¹å˜æ—¶ï¼Œå®ç°è¿˜å¿…é¡»åœ¨ç¨‹åºæ‰§è¡ŒæœŸé—´ä¸€è‡´åœ°è¿”å›ç›¸åŒçš„æ•´æ•°å“ˆå¸Œå€¼ã€‚æ•´æ•°å“ˆå¸Œå€¼ä¸å¿…åœ¨å¤šæ¬¡æ‰§è¡Œä¸­éƒ½ç›¸åŒã€‚

```cadence
struct interface Hashable: Equatable {
    pub hashValue: Int
}
```



```cadence
// Declare a structure named `Point` with two fields
// named `x` and `y` that have type `Int`.
//
// `Point` is declared to implement the `Hashable` interface,
// which also means it needs to implement the `Equatable` interface.
//
struct Point: Hashable {

    pub(set) var x: Int
    pub(set) var y: Int

    init(x: Int, y: Int) {
        self.x = x
        self.y = y
    }

    // Implementing the function `equals` will allow points to be compared
    // for equality and satisfies the `Equatable` interface.
    //
    pub fun equals(_ other: {Equatable}): Bool {
        if let otherPoint = other as? Point {
            // Points are equal if their coordinates match.
            //
            // The essential components are therefore the fields `x` and `y`,
            // which must be used in the implementation of the field requirement
            // `hashValue` of the `Hashable` interface.
            //
            return otherPoint.x == self.x
                && otherPoint.y == self.y
        } else {
            return false
        }
    }

    // Providing an implementation for the hash value field
    // satisfies the `Hashable` interface.
    //
    pub synthetic hashValue: Int {
        get {
            // Calculate a hash value based on the essential components,
            // the fields `x` and `y`.
            //
            var hash = 7
            hash = 31 * hash + self.x
            hash = 31 * hash + self.y
            return hash
        }
    }
}
```

[
](https://docs.onflow.org/cadence/language/access-control/)