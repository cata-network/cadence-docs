# å‡½æ•°

å‡½æ•°æ˜¯æ‰§è¡Œç‰¹å®šä»»åŠ¡çš„è¯­å¥åºåˆ—ã€‚å‡½æ•°å…·æœ‰å‚æ•°ï¼ˆè¾“å…¥ï¼‰å’Œå¯é€‰çš„è¿”å›å€¼ï¼ˆè¾“å‡ºï¼‰ã€‚å‡½æ•°æ˜¯ç±»å‹åŒ–çš„ï¼šå‡½æ•°ç±»å‹ç”±å‚æ•°ç±»å‹å’Œè¿”å›ç±»å‹ç»„æˆã€‚

å‡½æ•°æ˜¯å€¼ï¼Œå³å®ƒä»¬å¯ä»¥åˆ†é…ç»™å¸¸é‡å’Œå˜é‡ï¼Œå¹¶ä¸”å¯ä»¥ä½œä¸ºå‚æ•°ä¼ é€’ç»™å…¶ä»–å‡½æ•°ã€‚è¿™ç§è¡Œä¸ºé€šå¸¸è¢«ç§°ä¸ºâ€œfirst-classå‡½æ•°â€ã€‚

## å‡½æ•°å£°æ˜

å¯ä»¥ä½¿ç”¨`fun`å…³é”®å­—å£°æ˜å‡½æ•°ï¼Œåè·Ÿå£°æ˜åç§°ã€å‚æ•°ã€å¯é€‰è¿”å›ç±»å‹ä»¥åŠè°ƒç”¨å‡½æ•°æ—¶åº”æ‰§è¡Œçš„ä»£ç ã€‚

å‚æ•°éœ€è¦æ‹¬åœ¨æ‹¬å·ä¸­ã€‚è¿”å›ç±»å‹ï¼ˆå¦‚æœæœ‰ï¼‰ä¸å‚æ•°ä¹‹é—´ç”¨å†’å· ( `:`)åˆ†éš”ã€‚å‡½æ•°ä»£ç éœ€è¦ç”¨å·¦æ‹¬å·å’Œå³æ‹¬å·æ‹¬èµ·æ¥ã€‚

æ¯ä¸ªå‚æ•°éƒ½å¿…é¡»æœ‰ä¸€ä¸ªåç§°ï¼Œå³å‚æ•°å€¼åœ¨å‡½æ•°å†…å¯ç”¨çš„åç§°ã€‚

å¯ä»¥æä¾›é™„åŠ å‚æ•°æ ‡ç­¾ä»¥è¦æ±‚å‡½æ•°è°ƒç”¨ä½¿ç”¨æ ‡ç­¾ä¸ºå‚æ•°æä¾›å‚æ•°å€¼ã€‚

å‚æ•°æ ‡ç­¾ä½¿ä»£ç æ›´åŠ æ˜ç¡®å’Œå¯è¯»ã€‚ä¾‹å¦‚ï¼Œå½“æœ‰å¤šä¸ªç›¸åŒç±»å‹çš„å‚æ•°æ—¶ï¼Œå®ƒä»¬å¯ä»¥é¿å…æ··æ·†å‚æ•°çš„é¡ºåºã€‚

å‚æ•°æ ‡ç­¾åº”è¯¥å‘½åï¼Œä»¥ä¾¿ä»å‡½æ•°è°ƒç”¨çš„è§’åº¦æ¥çœ‹å®ƒä»¬æ˜¯æœ‰æ„ä¹‰çš„ã€‚

å‚æ•°æ ‡ç­¾ä½äºå‚æ•°åç§°ä¹‹å‰ã€‚ç‰¹æ®Šå‚æ•°æ ‡ç­¾`_`è¡¨ç¤ºå‡½æ•°è°ƒç”¨å¯ä»¥çœç•¥å‚æ•°æ ‡ç­¾ã€‚å¦‚æœå‡½æ•°å£°æ˜ä¸­æ²¡æœ‰å£°æ˜å‚æ•°æ ‡ç­¾ï¼Œåˆ™å‚æ•°åç§°ä¸ºå‡½æ•°å£°æ˜çš„å‚æ•°æ ‡ç­¾ï¼Œå‡½æ•°è°ƒç”¨å¿…é¡»ä½¿ç”¨å‚æ•°åç§°ä½œä¸ºå‚æ•°æ ‡ç­¾ã€‚

æ¯ä¸ªå‚æ•°éƒ½éœ€è¦æœ‰ä¸€ä¸ªç±»å‹æ³¨é‡Šï¼Œå®ƒè·Ÿåœ¨å†’å·åçš„å‚æ•°åç§°ä¹‹åã€‚

å‡½æ•°è°ƒç”¨å¯ä»¥ä¸ºä½œä¸ºå‚æ•°ç±»å‹å­ç±»å‹çš„å‚æ•°æä¾›å‚æ•°ã€‚

æœ‰**æ²¡æœ‰**å¯é€‰å‚æ•°ï¼Œå‚æ•°å³é»˜è®¤å€¼ï¼ŒåŠå¯å˜å‚æ•°çš„åŠŸèƒ½ï¼Œå³åˆ©ç”¨å‚æ•°ä»»æ„é‡‘é¢å³åŠŸèƒ½çš„æ”¯æŒã€‚

```cadence
// Declare a function named `double`, which multiples a number by two.
//
// The special argument label _ is specified for the parameter,
// so no argument label has to be provided in a function call.
//
fun double(_ x: Int): Int {
    return x * 2
}

// Call the function named `double` with the value 4 for the first parameter.
//
// The argument label can be omitted in the function call as the declaration
// specifies the special argument label _ for the parameter.
//
double(2)  // is `4`
```

æŸäº›å‚æ•°å¯èƒ½éœ€è¦å‚æ•°æ ‡ç­¾ï¼Œè€Œå…¶ä»–å‚æ•°ä¸éœ€è¦å‚æ•°æ ‡ç­¾ã€‚

```cadence
// Declare a function named `clamp`. The function takes an integer value,
// the lower limit, and the upper limit. It returns an integer between
// the lower and upper limit.
//
// For the first parameter the special argument label _ is used,
// so no argument label has to be given for it in a function call.
//
// For the second and third parameter no argument label is given,
// so the parameter names are the argument labels, i.e., the parameter names
// have to be given as argument labels in a function call.
//
fun clamp(_ value: Int, min: Int, max: Int): Int {
    if value > max {
        return max
    }

    if value < min {
        return min
    }

    return value
}

// Declare a constant which has the result of a call to the function
// named `clamp` as its initial value.
//
// For the first argument no label is given, as it is not required by
// the function declaration (the special argument label `_` is specified).
//
// For the second and this argument the labels must be provided,
// as the function declaration does not specify the special argument label `_`
// for these two parameters.
//
// As the function declaration also does not specify argument labels
// for these parameters, the parameter names must be used as argument labels.
//
let clamped = clamp(123, min: 0, max: 100)
// `clamped` is `100`
```



```cadence
// Declare a function named `send`, which transfers an amount
// from one account to another.
//
// The implementation is omitted for brevity.
//
// The first two parameters of the function have the same type, so there is
// a potential that a function call accidentally provides arguments in
// the wrong order.
//
// While the parameter names `senderAddress` and `receiverAddress`
// are descriptive inside the function, they might be too verbose
// to require them as argument labels in function calls.
//
// For this reason the shorter argument labels `from` and `to` are specified,
// which still convey the meaning of the two parameters without being overly
// verbose.
//
// The name of the third parameter, `amount`, is both meaningful inside
// the function and also in a function call, so no argument label is given,
// and the parameter name is required as the argument label in a function call.
//
fun send(from senderAddress: Address, to receivingAddress: Address, amount: Int) {
    // The function code is omitted for brevity.
    // ...
}

// Declare a constant which refers to the sending account's address.
//
// The initial value is omitted for brevity.
//
let sender: Address = // ...

// Declare a constant which refers to the receiving account's address.
//
// The initial value is omitted for brevity.
//
let receiver: Address = // ...

// Call the function named `send`.
//
// The function declaration requires argument labels for all parameters,
// so they need to be provided in the function call.
//
// This avoids ambiguity. For example, in some languages (like C) it is
// a convention to order the parameters so that the receiver occurs first,
// followed by the sender. In other languages, it is common to have
// the sender be the first parameter, followed by the receiver.
//
// Here, the order is clear â€“ send an amount from an account to another account.
//
send(from: sender, to: receiver, amount: 100)
```

å‡½æ•°è°ƒç”¨ä¸­å‚æ•°çš„é¡ºåºå¿…é¡»ä¸å‡½æ•°å£°æ˜ä¸­å‚æ•°çš„é¡ºåºåŒ¹é…ã€‚

```cadence
// Declare a function named `test`, which accepts two parameters, named `first` and `second`
//
fun test(first: Int, second: Int) {
    // ...
}

// Invalid: the arguments are provided in the wrong order,
// even though the argument labels are provided correctly.
//
test(second: 1, first: 2)
```

å‡½æ•°å¯ä»¥åµŒå¥—ï¼Œå³ä¸€ä¸ªå‡½æ•°çš„ä»£ç å¯ä»¥å£°æ˜æ›´å¤šçš„å‡½æ•°ã€‚

```cadence
// Declare a function which multiplies a number by two, and adds one.
//
fun doubleAndAddOne(_ x: Int): Int {

    // Declare a nested function which multiplies a number by two.
    //
    fun double(_ x: Int) {
        return x * 2
    }

    return double(x) + 1
}

doubleAndAddOne(2)  // is `5`
```

## å‡½æ•°é‡è½½

ğŸš§ çŠ¶æ€ï¼šæœªå®ç°å‡½æ•°é‡è½½ã€‚

å¯ä»¥å£°æ˜å…·æœ‰ç›¸åŒåç§°çš„å‡½æ•°ï¼Œåªè¦å®ƒä»¬å…·æœ‰ä¸åŒçš„å‚æ•°æ ‡ç­¾é›†ã€‚è¿™ç§°ä¸ºå‡½æ•°é‡è½½ã€‚

```cadence
// Declare a function named "assert" which requires a test value
// and a message argument.
//
fun assert(_ test: Bool, message: String) {
    // ...
}

// Declare a function named "assert" which only requires a test value.
// The function calls the `assert` function declared above.
//
fun assert(_ test: Bool) {
    assert(test, message: "test is false")
}
```

## å‡½æ•°è¡¨è¾¾å¼

å‡½æ•°ä¹Ÿå¯ä»¥ç”¨ä½œè¡¨è¾¾å¼ã€‚è¯­æ³•ä¸å‡½æ•°å£°æ˜ç›¸åŒï¼Œåªæ˜¯å‡½æ•°è¡¨è¾¾å¼æ²¡æœ‰åç§°ï¼Œå³å®ƒä»¬æ˜¯åŒ¿åçš„ã€‚

```cadence
// Declare a constant named `double`, which has a function as its value.
//
// The function multiplies a number by two when it is called.
//
// This function's type is `((Int): Int)`.
//
let double =
    fun (_ x: Int): Int {
        return x * 2
    }
```

## å‡½æ•°è°ƒç”¨

å¯ä»¥è°ƒç”¨ï¼ˆè°ƒç”¨ï¼‰å‡½æ•°ã€‚å‡½æ•°è°ƒç”¨éœ€è¦æä¾›ä¸å‡½æ•°æœ‰å‚æ•°ä¸€æ ·å¤šçš„å‚æ•°å€¼ã€‚

```cadence
fun double(_ x: Int): Int {
    return x * 2
}

// Valid: the correct amount of arguments is provided.
//
double(2)  // is `4`

// Invalid: too many arguments are provided.
//
double(2, 3)

// Invalid: too few arguments are provided.
//
double()
```

## å‡½æ•°ç±»å‹

å‡½æ•°ç±»å‹ç”±å‡½æ•°çš„å‚æ•°ç±»å‹å’Œå‡½æ•°çš„è¿”å›ç±»å‹ç»„æˆã€‚

å‚æ•°ç±»å‹éœ€è¦ç”¨æ‹¬å·æ‹¬èµ·æ¥ï¼Œåè·Ÿå†’å· ( `:`)ï¼Œå¹¶ä»¥è¿”å›ç±»å‹ç»“æŸã€‚æ•´ä¸ªå‡½æ•°ç±»å‹éœ€è¦ç”¨æ‹¬å·æ‹¬èµ·æ¥ã€‚first-class

```cadence
// Declare a function named `add`, with the function type `((Int, Int): Int)`.
//
fun add(a: Int, b: Int): Int {
    return a + b
}
```



```cadence
// Declare a constant named `add`, with the function type `((Int, Int): Int)`
//
let add: ((Int, Int): Int) =
    fun (a: Int, b: Int): Int {
        return a + b
    }
```

å¦‚æœå‡½æ•°æ²¡æœ‰è¿”å›ç±»å‹ï¼Œåˆ™å®ƒéšå¼å…·æœ‰è¿”å›ç±»å‹`Void`ã€‚



```cadence
// Declare a constant named `doNothing`, which is a function
// that takes no parameters and returns nothing.
//
let doNothing: ((): Void) =
    fun () {}
```

æ‹¬å·ä¹Ÿæ§åˆ¶ä¼˜å…ˆçº§ã€‚ä¾‹å¦‚ï¼Œå‡½æ•°ç±»å‹`((Int): ((): Int))`æ˜¯ä¸€ä¸ªå‡½æ•°çš„ç±»å‹ï¼Œå®ƒæ¥å—ä¸€ä¸ªå¸¦æœ‰ type çš„å‚æ•°`Int`ï¼Œå¹¶è¿”å›å¦ä¸€ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°ä¸æ¥å—ä»»ä½•å‚æ•°å¹¶è¿”å›ä¸€ä¸ª`Int`ã€‚

type`[((Int): Int); 2]`æŒ‡å®šäº†ä¸¤ä¸ªå‡½æ•°çš„æ•°ç»„ç±»å‹ï¼Œå®ƒä»¬æ¥å—ä¸€ä¸ªæ•´æ•°å¹¶è¿”å›ä¸€ä¸ªæ•´æ•°ã€‚

å‚æ•°æ ‡ç­¾ä¸æ˜¯å‡½æ•°ç±»å‹çš„ä¸€éƒ¨åˆ†ã€‚è¿™æ ·åšçš„å¥½å¤„æ˜¯ï¼Œåªè¦å‚æ•°ç±»å‹å’Œè¿”å›ç±»å‹åŒ¹é…ï¼Œå…·æœ‰ä¸åŒå‚æ•°æ ‡ç­¾çš„å‡½æ•°ï¼ˆå¯èƒ½ç”±ä¸åŒä½œè€…ç¼–å†™ï¼‰æ˜¯å…¼å®¹çš„ã€‚å®ƒçš„ç¼ºç‚¹æ˜¯å¯¹æ™®é€šå‡½æ•°å€¼çš„å‡½æ•°è°ƒç”¨ä¸èƒ½æ¥å—å‚æ•°æ ‡ç­¾ã€‚



```cadence
// Declare a function which takes one argument that has type `Int`.
// The function has type `((Int): Void)`.
//
fun foo1(x: Int) {}

// Call function `foo1`. This requires an argument label.
foo1(x: 1)

// Declare another function which takes one argument that has type `Int`.
// The function also has type `((Int): Void)`.
//
fun foo2(y: Int) {}

// Call function `foo2`. This requires an argument label.
foo2(y: 2)

// Declare a variable which has type `((Int): Void)` and use `foo1`
// as its initial value.
//
var someFoo: ((Int): Void) = foo1

// Call the function assigned to variable `someFoo`.
// This is valid as the function types match.
// This does neither require nor allow argument labels.
//
someFoo(3)

// Assign function `foo2` to variable `someFoo`.
// This is valid as the function types match.
//
someFoo = foo2

// Call the function assigned to variable `someFoo`.
// This does neither require nor allow argument labels.
//
someFoo(4)
```

## é—­åŒ…

å‡½æ•°å¯ä»¥å¼•ç”¨å®šä¹‰å®ƒçš„å¤–éƒ¨ä½œç”¨åŸŸçš„å˜é‡å’Œå¸¸é‡ã€‚å®ƒè¢«ç§°ä¸ºé—­åŒ…ï¼Œå› ä¸ºå®ƒå…³é—­äº†é‚£äº›å˜é‡å’Œå¸¸é‡ã€‚é—­åŒ…å¯ä»¥ä»å˜é‡å’Œå¸¸é‡ä¸­è¯»å–å¹¶åˆ†é…ç»™å®ƒæ‰€å¼•ç”¨çš„å˜é‡ã€‚



```cadence
// Declare a function named `makeCounter` which returns a function that
// each time when called, returns the next integer, starting at 1.
//
fun makeCounter(): ((): Int) {
    var count = 0
    return fun (): Int {
        // NOTE: read from and assign to the non-local variable
        // `count`, which is declared in the outer function.
        //
        count = count + 1
        return count
    }
}

let test = makeCounter()
test()  // is `1`
test()  // is `2`
```

## å‚æ•°ä¼ é€’è¡Œä¸º

å½“å‚æ•°ä¼ é€’ç»™å‡½æ•°æ—¶ï¼Œå®ƒä»¬è¢«å¤åˆ¶ã€‚å› æ­¤ï¼Œå½“å‡½æ•°è¿”å›æ—¶ï¼Œä¼ é€’ç»™å‡½æ•°çš„å€¼åœ¨è°ƒç”¨è€…çš„ä½œç”¨åŸŸä¸­æ˜¯ä¸å˜çš„ã€‚è¿™ç§è¡Œä¸ºè¢«ç§°ä¸º [call-by-value](https://en.wikipedia.org/w/index.php?title=Evaluation_strategy&oldid=896280571#Call_by_value)ã€‚



```cadence
// Declare a function that changes the first two elements
// of an array of integers.
//
fun change(_ numbers: [Int]) {
    // Change the elements of the passed in array.
    // The changes are only local, as the array was copied.
    //
    numbers[0] = 1
    numbers[1] = 2
    // `numbers` is `[1, 2]`
}

let numbers = [0, 1]

change(numbers)
// `numbers` is still `[0, 1]`
```

å‚æ•°æ˜¯å¸¸æ•°ï¼Œå³ä¸å…è®¸åˆ†é…ç»™å®ƒä»¬ã€‚



```cadence
fun test(x: Int) {
    // Invalid: cannot assign to a parameter (constant)
    //
    x = 2
}
```

## å‡½æ•°å‰ç½®æ¡ä»¶å’Œåç½®æ¡ä»¶

å‡½æ•°å¯èƒ½æœ‰å‰ç½®æ¡ä»¶ï¼Œä¹Ÿå¯èƒ½æœ‰åç½®æ¡ä»¶ã€‚å‰ç½®æ¡ä»¶å’Œåç½®æ¡ä»¶å¯ç”¨äºé™åˆ¶å‡½æ•°çš„è¾“å…¥ï¼ˆå‚æ•°å€¼ï¼‰å’Œè¾“å‡ºï¼ˆè¿”å›å€¼ï¼‰ã€‚

åœ¨æ‰§è¡Œå‡½æ•°ä¹‹å‰ï¼Œå‰ææ¡ä»¶å¿…é¡»ä¸ºçœŸã€‚å‰ç½®æ¡ä»¶æ˜¯å‡½æ•°çš„ä¸€éƒ¨åˆ†ï¼Œç”±`pre`å…³é”®å­—å¼•å…¥ï¼Œåè·Ÿæ¡ä»¶å—ã€‚

åç½®æ¡ä»¶å¿…é¡»åœ¨å‡½æ•°æ‰§è¡Œåç«‹å³ä¸ºçœŸã€‚åç½®æ¡ä»¶æ˜¯å‡½æ•°çš„ä¸€éƒ¨åˆ†ï¼Œç”±`post`å…³é”®å­—å¼•å…¥ï¼Œåè·Ÿæ¡ä»¶å—ã€‚åç½®æ¡ä»¶å¯èƒ½åªå‡ºç°åœ¨å‰ç½®æ¡ä»¶ä¹‹åï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰ã€‚

æ¡ä»¶å—ç”±ä¸€ä¸ªæˆ–å¤šä¸ªæ¡ä»¶ç»„æˆã€‚æ¡ä»¶æ˜¯è¯„ä¼°ä¸ºå¸ƒå°”å€¼çš„è¡¨è¾¾å¼ã€‚å®ƒä»¬ä¸èƒ½è°ƒç”¨å‡½æ•°ï¼Œå³å®ƒä»¬ä¸èƒ½æœ‰å‰¯ä½œç”¨å¹¶ä¸”å¿…é¡»æ˜¯çº¯è¡¨è¾¾å¼ã€‚æ­¤å¤–ï¼Œæ¡ä»¶å¯èƒ½ä¸åŒ…å«å‡½æ•°è¡¨è¾¾å¼ã€‚

æ¡ä»¶å¯ä»¥å†™åœ¨ä¸åŒçš„è¡Œä¸Šï¼Œæˆ–è€…å¤šä¸ªæ¡ä»¶å¯ä»¥å†™åœ¨åŒä¸€è¡Œä¸Šï¼Œç”¨åˆ†å·åˆ†éš”ã€‚æ­¤è¯­æ³•éµå¾ª[statements](https://docs.onflow.org/cadence/language/syntax#semicolons)çš„è¯­æ³•ã€‚

åœ¨æ¯ä¸ªæ¡ä»¶ä¹‹åï¼Œå¯ä»¥åœ¨å†’å·åæä¾›å¯é€‰çš„æè¿°ã€‚å½“æ¡ä»¶å¤±è´¥æ—¶ï¼Œæ¡ä»¶æè¿°ç”¨ä½œé”™è¯¯æ¶ˆæ¯ã€‚

åœ¨åç½®æ¡ä»¶ä¸­ï¼Œç‰¹æ®Šå¸¸é‡`result`æ˜¯æŒ‡å‡½æ•°çš„ç»“æœã€‚



```cadence
fun factorial(_ n: Int): Int {
    pre {
        // Require the parameter `n` to be greater than or equal to zero.
        //
        n >= 0:
            "factorial is only defined for integers greater than or equal to zero"
    }
    post {
        // Ensure the result will be greater than or equal to 1.
        //
        result >= 1:
            "the result must be greater than or equal to 1"
    }

    if n < 1 {
       return 1
    }

    return n * factorial(n - 1)
}

factorial(5)  // is `120`

// Run-time error: The given argument does not satisfy
// the precondition `n >= 0` of the function, the program aborts.
//
factorial(-2)
```

åœ¨åç½®æ¡ä»¶ä¸­ï¼Œç‰¹æ®Šå‡½æ•°`before`å¯ç”¨äºåœ¨è°ƒç”¨å‡½æ•°ä¹‹å‰è·å–è¡¨è¾¾å¼çš„å€¼ã€‚



```cadence
var n = 0

fun incrementN() {
    post {
        // Require the new value of `n` to be the old value of `n`, plus one.
        //
        n == before(n) + 1:
            "n must be incremented by 1"
    }

    n = n + 1
}
```

[
](https://docs.onflow.org/cadence/language/operators/)